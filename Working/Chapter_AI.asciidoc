== AI

[[navigation]]
=== Setting up a navigation mesh
// card: https://trello.com/c/FgBKCYBc

==== Problem

You want to use a navigation mesh, which allows your game objects to find paths around a scene.

==== Solution

Navigation meshes are easiest to set up when your level is made of objects that you don't expect to move during gameplay, such as the ground, walls, and other obstacles.

. Select the objects that you don't expect to move.
. At the top-right of the inspector, click the drop-down arrow, and choose Navigation Static (<<animation_navigation_static>>)

img: animation_navigation_static

NOTE: You can also select the Static checkbox, which will mark the selected objects static for all other purposes as well.

Once you have at least one object that's marked as Navigation Static, you can bake a navigation mesh.

. Open the Window menu, and choose Navigation.
. Go to the Bake tab. Click Bake.

A navigation mesh will be generated (<<animation_navigation_navmesh>>)

img: animation_navigation_navmesh

==== Discussion

Discuss what a navigation mesh is, and what it's used for (navigation agents are able to find paths around the mesh.)

[[navigation_paths]]
=== Finding paths on a navigation mesh
// card: https://trello.com/c/4T37UE45

==== Problem

You want to create an object that can find a path from its current location to a given destination, avoiding walls and other obstacles. You want to test this feature by clicking on the world and making the object try to move to where you clicked.

==== Solution

. First, ensure that your scene has a nav mesh, by following the steps in [[navigation]].
. Create a new Capsule by opening the GameObject menu and choosing 3D Object -> Capsule.
. Add a Nav Mesh Agent to the capsule.
. Create a new C# script called MoveToPoint, and add the following code to it:

// snip: navigation_move_to_point
[source,csharp]
----
using UnityEngine.AI;
// When the player clicks on a part of the world, the NavMeshAgent moves
// to that position.
[RequireComponent(typeof(NavMeshAgent))]
public class MoveToPoint : MonoBehaviour
{

    // The agent we'll be moving around.
    NavMeshAgent agent;

    void Start()
    {
        // Cache a reference to the nav mesh agent on game start
        agent = GetComponent<NavMeshAgent>();
    }

    // When the user clicks, move the agent.
    void Update()
    {

        // Did the user just click the left mouse button?
        if (Input.GetMouseButtonDown(0))
        {

            // Get the position on screen, in screen coordinates (ie pixels.)
            var mousePosition = Input.mousePosition;

            // Convert this position into a ray that starts at the camera
            // and moves towards where the mouse cursor is.
            var ray = Camera.main.ScreenPointToRay(mousePosition);

            // Store information about any raycast hit in this variable.
            RaycastHit hit;

            // Did the ray hit something?
            if (Physics.Raycast(ray, out hit))
            {

                // Figure out where the ray hit an object.
                var selectedPoint = hit.point;

                // Tell the agent to start walking to that point.
                agent.destination = selectedPoint;

            }
        }
    }
}
----

. Add a MoveToPoint component to the capsule.

. Play the game. Click on somewhere in the world, and the capsule will start walking to the point you clicked.

==== Discussion

Discuss how agents may not be able to reach the point you specify; rather, they'll do their best.

[[enemy_visibility]]
=== Enemies detecting when they can see the player
// card: https://trello.com/c/odXKNOIB

==== Problem

You want an object to be able to detect when it can "see" its target; that is, the target is both close enough to the object, and is in front of the object. You want to be able to visualise and configure the area in which targets can be seen.

==== Solution

. Create a new script called EnemyVisibility.cs, and add the following code to it:

// snip: enemy_visibility
[source,csharp]
----
#if UNITY_EDITOR
using UnityEditor;
#endif

// Detects when a given target is visible to this object. A target is visible
// when it's both in range and in front of the target. Both the range and the
// angle of visibility are configurable.
public class EnemyVisibility : MonoBehaviour
{

    // The object we're looking for.
    public Transform target = null;

    // If the object is more than this distance away, we can't see it.
    public float maxDistance = 10f;

    // The angle of our arc of visibility.
    [Range(0f, 360f)]
    public float angle = 45f;

    // If true, visualise changes in visilibity by changing material colour
    [SerializeField] bool visualize = true;

    // A property that other classes can access to determine if we can currently
    // see our target.
    public bool targetIsVisible { get; private set; }

    // Check to see if we can see the target every frame.
    void Update()
    {
        targetIsVisible = CheckVisibility();

        if (visualize) {
            // Update our colour; yellow if we can see the target, white if 
            // we can't
            var color = targetIsVisible ? Color.yellow : Color.white;

            GetComponent<Renderer>().material.color = color;
        }

    }

    // Returns true if this object can see the specified position.
    public bool CheckVisibilityToPoint(Vector3 worldPoint) {

        // Calculate the direction from our location to the point
        var directionToTarget = worldPoint - transform.position;

        // Calculate the number of degrees from the forward direction.
        var degreesToTarget = 
            Vector3.Angle(transform.forward, directionToTarget);

        // The target is within the arc if it's within half of the specified
        // angle.
        // If it's not within the arc, it's not visible.
        var withinArc = degreesToTarget < (angle / 2);

        if (withinArc == false)
        {
            return false;
        }

        // Figure out the distance to the target
        var distanceToTarget = directionToTarget.magnitude;

        // Take into account our maximum distance
        var rayDistance = Mathf.Min(maxDistance, distanceToTarget);

        // Create a new ray that goes from our current location, in the 
        // specified direction
        var ray = new Ray(transform.position, directionToTarget);

        // Stores information about anything we hit
        RaycastHit hit;

        // Perform the raycast. Did it hit anything?
        if (Physics.Raycast(ray, out hit, rayDistance)) {
            // We hit something. 
            if (hit.collider.transform == target) {
                // It was the target itself. We can see the target point.
                return true;
            }
            // It's something between us and the target. We cannot see the 
            // target point.
            return false;
        } else {
            // There's an unobstructed line of sight between us and the target
            // point, so we can see it.
            return true;
        }
    }

    // Returns true if a straight line can be drawn between this object and the
    // target. The target must be within range, and be within the visible arc.
    public bool CheckVisibility()
    {        
        // Compute the direction to the target
        var directionToTarget = target.position - transform.position;

        // Calculate the number of degrees from the forward direction.
        var degreesToTarget = 
            Vector3.Angle(transform.forward, directionToTarget);

        // The target is within the arc if it's within half of the specified
        // angle.
        // If it's not within the arc, it's not visible.
        var withinArc = degreesToTarget < (angle / 2);

        if (withinArc == false) {
            return false;
        }

        // Compute the distance to the point
        var distanceToTarget = directionToTarget.magnitude;

        // Our ray should go as far as the target is, or the maximum distance,
        // whichever is shorter
        var rayDistance = Mathf.Min(maxDistance, distanceToTarget);

        // Create a ray that fires out from our position to the target
        var ray = new Ray(transform.position, directionToTarget);

        // Store information about what was hit in this variable
        RaycastHit hit;

        // Records info about whether the target is in range and not occluded
        var canSee = false;

        // Fire the raycast. Did it hit anything?
        if (Physics.Raycast(ray, out hit, rayDistance))
        {
            // Did the ray hit our target?
            if (hit.collider.transform == target)
            {
                // Then we can see it (that is, the ray didn't hit an obstacle
                // in between us and the target)
                canSee = true;
            }

            // Visualise the ray.
            Debug.DrawLine(transform.position, hit.point);

        }
        else
        {
            // The ray didn't hit anything. This means that it reached the
            // maximum distance, and stopped, which means we didn't hit our
            // target. It must be out of range.

            // Visualise the ray.
            Debug.DrawRay(transform.position, 
                          directionToTarget.normalized * rayDistance);
        }

        // Is it visible?
        return canSee;

    }
}

#if UNITY_EDITOR
// A custom editor for the EnemyVisibility class. Visualises and allows
// editing the visible range.
[CustomEditor(typeof(EnemyVisibility))]
public class EnemyVisibilityEditor : Editor {

    // Called when Unity needs to draw the Scene view. 
    private void OnSceneGUI()
    {
        // Get a reference to the EnemyVisibility script we're looking at
        var visibility = target as EnemyVisibility;

        // Start drawing at 10% opacity
        Handles.color = new Color(1, 1, 1, 0.1f);

        // Drawing an arc sweeps from the point you give it. We want to draw 
        // the arc such that the middle of the arc is in front of the object,
        // so we'll take the forward direction and rotate it by half the angle.

        var forwardPointMinusHalfAngle = 
            // rotate around the Y axis by half the angle
            Quaternion.Euler(0, -visibility.angle / 2, 0) 
                      // rotate the forward direction by this
                      * visibility.transform.forward;

        // Draw the arc to visualise the visibility arc
        Vector3 arcStart = forwardPointMinusHalfAngle * visibility.maxDistance;

        Handles.DrawSolidArc(
            visibility.transform.position, // The center of the arc
            Vector3.up,                    // The up-direction of the arc
            arcStart,                      // The point where the arc begins
            visibility.angle,              // The angle of the arc
            visibility.maxDistance         // The radius of the arc
        );


        // Draw a scale handle at the edge of the arc; if the user drags it,
        // update the arc size.

        // Reset the handle colour to full opacity
        Handles.color = Color.white;

        // Compute the position of the handle, based on the object's position,
        // the direction it's facing, and the distance
        Vector3 handlePosition = 
            visibility.transform.position + 
                  visibility.transform.forward * visibility.maxDistance;

        // Draw the handle, and store its result.
        visibility.maxDistance = Handles.ScaleValueHandle(
            visibility.maxDistance,         // current value
            handlePosition,                 // handle position
            visibility.transform.rotation,  // orientation
            1,                              // size
            Handles.ConeHandleCap,          // cap to draw
            0.25f);                         // snap to multiples of this if 
                                            // the snapping key is held down
    }
}
#endif
----

. Create two capsules in the scene, by opening the GameObject menu and choosing 3D Object -> Capsule.

. Add an EnemyVisibility component to one of the capsules. Make its Target field refer to the other capsule. Note how you can see the visibility arc (<<ai_visibility_cone>>)

img: ai_visibility_cone

. Play the game. The capsule with the EnemyVisibility component will turn bright yellow when it can see its target. 


==== Discussion

Discuss the algorithm used by this component (basically follow the comments)


=== Finding a good distribution of random points (poisson disc)
// card: https://trello.com/c/mWF5bleN

==== Problem

You want to efficiently find a random collection of points in a given area.

==== Solution

Use a Poisson disc distribution.

Create a new C# script called PoissonDiscSampler.cs and add the following code to it.

// snip: poisson_disc_sampler
[source,csharp]
----
// With thanks to Gregory Schlomoff, who wrote this implementation
// and released it into the public domain, and to Robert Bridson of the 
// University of British Columbia, for developing the efficient algorithm
// that this code implements.

// http://gregschlom.com/devlog/2014/06/29/Poisson-disc-sampling-Unity.html
// http://www.cs.ubc.ca/~rbridson/docs/bridson-siggraph07-poissondisk.pdf

// Generates a distribution of 2D points that aren't too close to each other.
// Operates in O(N) time.
public class PoissonDiscSampler
{
    // Maximum number of attempts before marking a sample as inactive.
    private const int k = 30;  

    // The rectangle in which points will be placed
    private readonly Rect rect;

    // radius squared
    private readonly float radius2;  

    // The cell size of the grid of points
    private readonly float cellSize;

    // The grid of points
    private Vector2[,] grid;

    // The list of locations near which we're trying to add new points to.
    private  List<Vector2> activeSamples = new List<Vector2>();

    // Create a sampler with the following parameters:
    //
    // width:  each sample's x coordinate will be between [0, width]
    // height: each sample's y coordinate will be between [0, height]
    // radius: each sample will be at least `radius` units away from any other 
    // sample, and at most 2 * `radius`.
    public PoissonDiscSampler(float width, float height, float radius)
    {
        rect = new Rect(0, 0, width, height);
        radius2 = radius * radius;
        cellSize = radius / Mathf.Sqrt(2);
        grid = new Vector2[Mathf.CeilToInt(width / cellSize),
                           Mathf.CeilToInt(height / cellSize)];
    }

    // Return a lazy sequence of samples. You typically want to call this in 
    // a foreach loop, like so:
    //   foreach (Vector2 sample in sampler.Samples()) { ... }
    public IEnumerable<Vector2> Samples()
    {
        // First sample is chosen randomly
        Vector2 firstSample = new Vector2(Random.value * rect.width, 
                                          Random.value * rect.height);

        yield return AddSample(firstSample);

        while (activeSamples.Count > 0) {

            // Pick a random active sample
            int i = (int) Random.value * activeSamples.Count;
            Vector2 sample = activeSamples[i];

            // Try `k` random candidates between [radius, 2 * radius] from that
            // sample.
            bool found = false;
            for (int j = 0; j < k; ++j) {

                float angle = 2 * Mathf.PI * Random.value;

                float r = Mathf.Sqrt(Random.value * 3 * radius2 + radius2); 

                Vector2 candidate = sample + r * new Vector2(
                    Mathf.Cos(angle), Mathf.Sin(angle));

                // Accept candidates if it's inside the rect and farther than 
                // 2 * radius to any existing sample.
                if (rect.Contains(candidate) && IsFarEnough(candidate)) {
                    found = true;
                    yield return AddSample(candidate);
                    break;
                }
            }

            // If we couldn't find a valid candidate after k attempts, remove
            // this sample from the active samples queue
            if (!found) {
                activeSamples[i] = activeSamples[activeSamples.Count - 1];
                activeSamples.RemoveAt(activeSamples.Count - 1);
            }
        }
    }

    private bool IsFarEnough(Vector2 sample)
    {
        GridPos pos = new GridPos(sample, cellSize);

        int xmin = Mathf.Max(pos.x - 2, 0);
        int ymin = Mathf.Max(pos.y - 2, 0);
        int xmax = Mathf.Min(pos.x + 2, grid.GetLength(0) - 1);
        int ymax = Mathf.Min(pos.y + 2, grid.GetLength(1) - 1);

        for (int y = ymin; y <= ymax; y++) {
            for (int x = xmin; x <= xmax; x++) {
                Vector2 s = grid[x, y];
                if (s != Vector2.zero) {
                    Vector2 d = s - sample;
                    if (d.x * d.x + d.y * d.y < radius2) return false;
                }
            }
        }

        return true;

        // Note: we use the zero vector to denote an unfilled cell in the grid.
        // This means that if we were to randomly pick (0, 0) as a sample, it
        // would be ignored for the purposes of proximity-testing and we might
        // end up with another sample too close from (0, 0). This is a very
        // minor issue.
    }

    // Adds the sample to the active samples queue and the grid before
    // returning it
    private Vector2 AddSample(Vector2 sample)
    {
        activeSamples.Add(sample);
        GridPos pos = new GridPos(sample, cellSize);
        grid[pos.x, pos.y] = sample;
        return sample;
    }

    // Helper struct to calculate the x and y indices of a sample in the grid
    private struct GridPos
    {
        public int x;
        public int y;

        public GridPos(Vector2 sample, float cellSize)
        {
            x = (int)(sample.x / cellSize);
            y = (int)(sample.y / cellSize);
        }
    }
}
----

NOTE: This script doesn't define a new component. Instead, it defines a class that other scripts can make use of.

To test this, create a new C# script called PoissonDiscDemo.cs and add the following code to it:

// snip: poisson_disc_demo
[source,csharp]
----
public class PoissonDiscDemo : MonoBehaviour {


    // The area in which we'll place our points
    [SerializeField] Vector2 size = new Vector2(10,10);

    // The points won't be any closer than this to each other
    [SerializeField] float cellSize = 0.5f;

    // The list of points we'll show
    List<Vector3> points;

    // Calculate the points to show when the game starts
    private void Awake()
    {
        // Create a list of points from the sampler
        points = new List<Vector3>();

        var sampler = new PoissonDiscSampler(size.x, size.y, cellSize);

        foreach (var point in sampler.Samples()) {
            points.Add(new Vector3(point.x, transform.position.y, point.y));
        }
    }

    // Visualise the points we've calculated
    private void OnDrawGizmos()
    {
        // Early out if we have no list to use
        if (points == null) {
            return;
        }

        Gizmos.color = Color.white;

        // Draw each point in the scene
        foreach (var point in points) {
            Gizmos.DrawSphere(transform.position + point, 0.1f);
        }
    }

}
----

Next, create an empty game object, and add a PoissonDiscDemo component to it. Play the game, and notice how it creates a randomly-positioned field of dots. Note also that the dots are fairly evenly distributed - they don't bunch up together, and there are no sparse areas (<<ai_poisson>>)

img: ai_poisson

==== Discussion

Discuss how random noise is useful - it makes things look less artificial, and can serve as the basis for making decisions about things like pathfinding (which is what it's used for in the next recipe)

=== Enemies detecting where they can take cover
// card: https://trello.com/c/CgqBpjWz

==== Problem

You want to create an object that hides from another object, taking into account that object's ability to see things and the surrounding environment.

==== Solution

. Create a new C# script called EnemyAvoider.cs, and add the following code to it:

// snip: enemy_avoider
[source,csharp]
----
using UnityEngine.AI;

// Detects if the target can see us, and if it can, navigates to somewhere
// they can't.
[RequireComponent(typeof(NavMeshAgent))]
public class EnemyAvoider : MonoBehaviour {

    // The object that's looking for us. We'll use it to determine if it can
    // see us, and if it can see the places we're considering hiding.
    [SerializeField] EnemyVisibility visibility = null;

    // The size of the area where we're considering hiding.
    [SerializeField] float searchAreaSize = 10f;

    // The density of the search field. Larger numbers means fewer hiding places
    // are considered, but it's more efficient.
    [SerializeField] float searchCellSize = 1f;

    // If true, lines will be drawn indicating where we're considering hiding.
    [SerializeField] bool visualize = true;

    // The navigation agent, which will navigate to the best hiding place.
    NavMeshAgent agent;

    // The Start method is a coroutine; when the game starts, it will start
    // a continuous cycle of avoiding the target.
    IEnumerator Start()
    {
        // Cache a reference to our navigation agent
        agent = GetComponent<NavMeshAgent>();

        // Do this forever:
        while (true) {

            // Can the target see us?
            if (visibility.targetIsVisible) {

                // Find a place to run to where it can't see us anymore.

                Vector3 hidingSpot;

                if (FindHidingSpot(out hidingSpot) == false) {
                    // We didn't find anywhere to hide! wait a second and try 
                    // again.
                    yield return new WaitForSeconds(1.0f);
                    continue;
                }

                // Tell the agent to start moving to this location
                agent.destination = hidingSpot;
            }

            // Wait a bit, and then check to see if the target can still see
            // us.
            yield return new WaitForSeconds(0.1f);
        }
    }

    // Attempts to find a nearby place that the target can't see us at. Returns
    // true if one was found; if 
    bool FindHidingSpot(out Vector3 hidingSpot) {

        var distribution = new PoissonDiscSampler(searchAreaSize, searchAreaSize, searchCellSize);

        var candidateHidingSpots = new List<Vector3>();

        foreach (var point in distribution.Samples()) {

            var searchPoint = point;

            // Re-position the point so that the middle of the search area
            // is at (0,0)
            searchPoint.x -= searchAreaSize / 2f;
            searchPoint.y -= searchAreaSize / 2f;

            var searchPointLocalSpace = new Vector3(
                searchPoint.x,
                transform.localPosition.y,
                searchPoint.y
            );

            // Can they see us from here?
            var searchPointWorldSpace = 
                transform.TransformPoint(searchPointLocalSpace);

            // Find the nearest point on the navmesh
            NavMeshHit hit;

            bool foundPoint;

            foundPoint = NavMesh.SamplePosition(
                searchPointWorldSpace, 
                out hit, 
                5, 
                NavMesh.AllAreas
            );

            if (foundPoint == false) {
                // We can't get here. Disregard as a place to hide.
                continue;
            }

            searchPointWorldSpace = hit.position;

            var canSee = visibility.CheckVisibilityToPoint(searchPointWorldSpace);


            if (canSee == false) {
                // we can't see the target from this position. return it!
                candidateHidingSpots.Add(searchPointWorldSpace);

            }

            if (visualize) {
                Color debugColor = canSee ? Color.red : Color.green;

                Debug.DrawLine(transform.position, searchPointWorldSpace, debugColor, 0.1f);
            }


        }

        if (candidateHidingSpots.Count == 0) {
            // We didn't find a hiding spot.

            // Provide a dummy value
            hidingSpot = Vector3.zero;

            // Indicate our failure
            return false;
        }


        // For each of our candidate points, calculate the length of the path
        // needed to reach it.

        // Build a list of candidate points, matched with the length of the
        // path needed to reach it.
        List<KeyValuePair<Vector3, float>> paths;

        // For each point, calculate the length
        paths = candidateHidingSpots.ConvertAll(
            (Vector3 point) => {

            // Create a new path that reaches this point
            var path = new NavMeshPath();
            agent.CalculatePath(point, path);

            // Store the distance needed for this path
            float distance;

            if (path.status != NavMeshPathStatus.PathComplete)
            {
                // If this path doesn't reach the target, consider it infinitely
                // far away
                distance = Mathf.Infinity;
            }
            else
            {

                // Get up to 32 of the points on this path
                var corners = new Vector3[32];
                var cornerCount = path.GetCornersNonAlloc(corners);

                // Start with the first point
                Vector3 current = corners[0];

                distance = 0;

                // Figure out the cumulative distance for each point
                for (int c = 1; c < cornerCount; c++)
                {
                    var next = corners[c];
                    distance += Vector3.Distance(current, next);
                    current = next;
                }
            }

            // Build the pair of point and distance
            return new KeyValuePair<Vector3, float>(point, distance);
        });

        // Sort this list based on distance, so that the shortest path is at
        // the front of the list
        paths.Sort((a, b) =>
        {
            return a.Value.CompareTo(b.Value);
        });

        // Return the point that's the shortest to reach
        hidingSpot = paths[0].Key;
        return true;


    }

}
----

. Add an EnemyAvoider script to the object that should be hiding from the target.

. Ensure that the target has an EnemyVisibility component (from <<enemy_visibility>>).

. Set the Visbility field to the target.

. Play the game. When the avoider can be seen by the target, it looks for a place where it can't be seen, and moves to it (<<ai_avoiding>>)

img: ai_avoiding The avoider, currently in the process of looking for a place to hide. Red lines point to places where it can be see, while green lines point to places where it can't be seen.

==== Discussion

Discuss how this algorithm works: every so often, if the target can see us, it generates a collection of random points nearby, and for each point, figures out if the target can see that point. Any point that can be seen is discarded. All remaining points are then tested to see if they can be reached; any point that can't be is discarded. Finally, each point is tested to find the length of the path to reach it, and the shortest is selected.

For better performance, increase the Search Cell Size to reduce the number of possible hiding spots that are tested, and if you've still got too many points, reduce the Search Area Size to reduce the range of possible hiding spots.

=== Building and using a state machine
// card: https://trello.com/c/sZ6MKKEF

==== Problem

You want to use a state machine, which is a programming pattern that lets you manage the various states that an object can be in.

==== Solution

. Create a new C# script called StateMachine, and add the following code to it:

// snip: statemachine
[source,csharp]
----
// Manages a collection of states, which can be transitioned from and to.
public class StateMachine {

    // A single state.
    public class State
    {
        // The state's visible name. Also used to identify the state to the
        // state machine.
        public string name;

        // Called every frame while the state is active.
        public System.Action onFrame;

        // Called when the state is transitioned to from another state.
        public System.Action onEnter;

        // Called when the state is transitioning to another state.
        public System.Action onExit;

        public override string ToString()
        {
            return name;
        }
    }

    // The collection of named states.
    Dictionary<string, State> states = new Dictionary<string, State>();

    // The state that we're currently in.
    public State currentState { get; private set; }

    // The state that we'll start in.
    public State initialState;

    // Creates, registers and returns a new named state.
    public State CreateState(string name) {

        // Create the state
        var newState = new State();

        // Give it a name
        newState.name = name;

        // If this is the first state, it will be our initial state
        if (states.Count == 0)
        {
            initialState = newState;
        }

        // Add it to the dictionary
        states[name] = newState;

        // And return it, so that it can be further configured
        return newState;
    }

    // Updates the current state.
    public void Update() {

        // If we don't have any states to use, log the error.
        if (states.Count == 0 || initialState == null) {
            Debug.LogErrorFormat("State machine has no states!");
            return;
        }

        // If we don't currently have a state, transition to the initial state.
        if (currentState == null) {
            TransitionTo(initialState);
        }

        // If the current state has an onFrame method, call it.
        if (currentState.onFrame != null) {
            currentState.onFrame();
        }
    }

    // Transitions to the specified state.
    public void TransitionTo(State newState) {

        // Ensure we weren't passed null
        if (newState == null)
        {
            Debug.LogErrorFormat("Cannot transition to a null state!");
            return;
        }

        // If we have a current state and that state has an on exit method,
        // call it
        if (currentState != null && currentState.onExit != null)
        {
            currentState.onExit();
        }

        Debug.LogFormat("Transitioning from '{0}' to '{1}'", currentState, newState);

        // This is now our current state
        currentState = newState;

        // If the new state has an on enter method, call it
        if (newState.onEnter != null)
        {
            newState.onEnter();
        }
    }

    // Transitions to a named state.
    public void TransitionTo(string name) {

        if (states.ContainsKey(name) == false) {
            Debug.LogErrorFormat("State machine doesn't contain a state " +
                                 "named {0}!", name);
            return;
        }

        // Find the state in the dictionary
        var newState = states[name];

        // Transition to it
        TransitionTo(newState);

    }

}
----

This +StateMachine+ class can be used like this:

// snip: statemachine_demo
[source,csharp]
----
// Demonstrates a state machine. This object has two states: 'searching', and
// 'aiming'. When the target is in range, it transitions from 'searching' to
// 'aiming'; when the target leaves range, it transitions back.
public class Turret : MonoBehaviour {

    // The object we'll rotate to aim
    [SerializeField] Transform weapon;

    // The object we're trying to aim at
    [SerializeField] Transform target;

    // Aim at the target when it's within this range
    [SerializeField] float range = 5f;

    // The arc that we'll turn in while the target is out of range
    [SerializeField] float arc = 45;

    // The state machine that manages this object
    StateMachine stateMachine;

    // Use this for initialization
	void Start () {

        // Create the state machine
        stateMachine = new StateMachine();

        // The first state we register will be the initial state
        var searching = stateMachine.CreateState("searching");

        // Log when we enter the state
        searching.onEnter = delegate {
            Debug.Log("Now searching for the target...");
        };

        // Each frame, animate the turret, and also check to see if the
        // target is in range
        searching.onFrame = delegate {

            // Sweep from side to side
            var angle = Mathf.Sin(Time.time) * arc / 2f;
            weapon.eulerAngles = Vector3.up * angle;

            // Find the distance to our target
            float distanceToTarget = 
                Vector3.Distance(transform.position, target.position);

            // Are they in range?
            if (distanceToTarget <= range) {
                // Then transition to the aiming state
                stateMachine.TransitionTo("aiming");
            }
        };

        // The aiming state runs when the target is in range.
        var aiming = stateMachine.CreateState("aiming");

        // Every frame, keep the turret aimed at the target. Detect when the
        // target leaves range.
        aiming.onFrame = delegate {

            // Aim the weapon at the target
            weapon.LookAt(target.position);

            // Transition back to 'searching' when it's out of range
            float distanceToTarget =
                Vector3.Distance(transform.position, target.position);

            if (distanceToTarget > range)
            {
                stateMachine.TransitionTo("searching");
            }
        };

        // 
        aiming.onEnter = delegate {
            Debug.Log("Target is in range!");
        };

        aiming.onExit = delegate {
            Debug.Log("Target went out of range!");
        };
	}

	void Update () {
        // Update the state machine's current state
        stateMachine.Update();
	}
}
----

==== Discussion

Discuss the theory of state machines.
