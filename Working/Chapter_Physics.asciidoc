== Physics and Character Control

[[implementing-mouse-look]]
=== Implementing mouse-look
// card: https://trello.com/c/l316UaPX

==== Problem

In a first-person game, you want to be able to control the direction that the player is looking at by using the mouse.

==== Solution

Implementing mouse-look involves rotating two separate objects - the body, and the head. The body rotates around the Y axis (also known as the "yaw" axis - the line that goes from down to up), while the head rotates around the X axis (the line that goes from left to right). In a first-person game, the camera is attached to the head.

. Create a new empty game object. Call it Player.
. Locate the Main Camera object. If you don't have one, open the GameObject menu, and choose Camera.
. Drag the camera object into the Player object, and rename it "Head".

. Position the Head where you want the head to be. For best results, don't modify any component of the position other than the Y component; the others should be at zero. This means that the camera will be directly above the center of the body.

. Create a new C# script called MouseLook, with the following code:

// snip: mouse_look

. Attach a MouseLook component to the body.

. Play the game. Moving the mouse will rotate the body and the head.


==== Discussion

Discuss inverting the mouse by modifying the vertical input.

<<controlling-a-3d-character>>
=== Controlling a 3D character
// card: https://trello.com/c/vDYcPQK3

==== Problem

You want to control a character in 3D space.

==== Solution

You'll typically want to start with mouse-look first, since without the ability to turn, you'll only be able to move forward, backwards, and side-to-side. We'll assume that you've followed the steps in <<implementing-mouse-look>>.

. Add a Character Controller component to your Player object.
. Move the Head to the top of the Character Controller.

. Create a new C# script called Movement. Add the following code to it:

// snip: 3d_movement

. Attach a Movement component to your Player object.

. Play the game. Pressing the arrow keys, or the W, A, S and D keys will move the player around (unless you've customised your input system). You can also jump by pressing the Spacebar.

==== Discussion

Discuss how for the best-feeling control, you generally want to manage the movement yourself, rather than doing it in physics. (Discuss why; good chance to mention how Mario games feel good to control, but are physically very unrealistic. Cite Steve Swink's "Game Feel".)

Note that this setup will be used in several other recipes in this chapter, since it's a good foundation.

[[interacting-with-switches-and-objects]]
=== Interacting with switches and objects
// card: https://trello.com/c/PGwgakP3

==== Problem

You want players to be able to aim at objects, and press a 'use' key. Certain objects should react to being interacted with in this way.

==== Solution

NOTE: This recipe assumes that you've set up your player by following <<implementing-mouse-look>> and <<controlling-a-3d-character>>.

Interacting with objects requires firing invisible rays out of the camera, in order to detect what you're looking at. The rays will stop at the first collider they see that's within range; we need to ensure that we never hit the Character Collider.

. Open the Edit menu, and choose Project Settings -> Tags and Layers.
. Set one of the blank User Layers to "Player".
. Select your Player object - the one that contains the CharacterController.
. Open the Layers menu at the top-right corner of the Inspector, and choose "Player". When you're asked if you want to set the layer of the child objects as well, click "Yes, change children.""

. Create a new C# script called Interactable. Add the following code to it:

// snip: interactable

. Attach this component to the object you want to interact with. The object must have a collider of some kind.

. Create a new C# script called Interacting. Add the following code to it:

// snip: interacting

. Attach this component to your Head object. Play the game; when you look at a nearby object that has the Interactable component and press the interaction key, the Interactable component will log that it's been interacted with.

==== Discussion

Discuss layers and layer masks, and why they're needed here (to prevent the rays from colliding with the player itself.)

=== Picking up and putting down objects
// card: https://trello.com/c/mM8NXoTN

==== Problem

You want to be able to pull objects towards you, and if they're close enough, pick them up. You want to be able to throw objects you're holding.

==== Solution

NOTE: This recipe assumes that you've set up your player by following <<implementing-mouse-look>> and <<controlling-a-3d-character>>. You'll also need to set up the Player layer, as per the <<interacting-with-switches-and-objects>> recipe.

. Create a new C# script called Grabbing, and add the following code to it:

// snip: grabbing

To test it, create a cube, scale it to (0.25,0.25,0.25), and add a Rigidbody. When you play the game, you will be able to pull it towards you by pressing the E key. When it's in range, you will grab it. Press the left mouse button to throw the object you're holding.

==== Discussion

This is basically a gravity gun.

Experiment with directly setting the velocity of thrown objects.

Experiment with different pulling and grabbing ranges.

Experiment with only being able to pick up objects below a certain mass (so that you can't pick up eg a massive rock)

=== Detecting when an object is touching another object
// card: https://trello.com/c/WUnyXSow

==== Problem

You want to detect when two physical objects are touching.

==== Solution



// snip: collision_detection


==== Discussion

Discuss how collisions will only be detected when at least one of the two colliding objects has a non-kinematic rigidbody. Discuss what a kinematic rigidbody is.

=== Detecting when an object is in a trigger area
// card: https://trello.com/c/VeFzmeOw

==== Problem

You want to detect when an object has entered a collider that's marked as a trigger.

==== Solution

// snip: trigger_detection

==== Discussion

Discuss what a trigger means, in the context of colliders.


[[implementing-moving-platforms]]
=== Implementing moving platforms
// card: https://trello.com/c/yCFwEnJC

==== Problem

You want objects to move from point to point.

==== Solution

. Create a new C# script called MovingPlatform, and add the following code to it:

// snip: moving_platform

. Create a new cube, and add a MovingPlatform to it.
. Add as many points to it as you'd like. They'll be displayed in the scene view.
. Play the game. The object will move to each of the points, in a circuit.

==== Discussion

Discuss how, without additional code, the platform will move through the player.

Note that the platform code stores its velocity; this is used in <<implementing-platform-riding>>

[[implementing-platform-riding]]
=== Implementing platform riding
// card: https://trello.com/c/1EkgT8nD

==== Problem

You want your character controller to be able to stand on a moving platform, as implemented in <<implementing-moving-platforms>>. You also want the character controller to be pushed out of the way, if a moving platform moves into it sideways.


==== Solution

. Create a new C# script called PlatformRiding, and add the following code to it.

// snip: platform_riding
[source,csharp]
----
// Implements platform riding (standing on a moving platform means we'll move
// with the platform), and pushing (if an object moves into us, it will push
// us away)
[RequireComponent(typeof(CharacterController))]
public class PlatformRiding : MonoBehaviour {

    // The CharacterController on this object.
    CharacterController controller;

    private void Start()
    {
        // We'll be checking our character controller a lot. Cache a reference
        // to it.
        controller = GetComponent<CharacterController>();
    }

    // Every time physics updates, check to see if our collider is overlapping 
    // something, and if it is, push ourselves out of it.
    private void FixedUpdate()
    {
        // First, we'll handle pushing the character collider out of the way
        // if another object moves into it.

        // A character collider's physical shape is a capsule. We need to
        // ask the physics system if this capsule is overlapping anything else;
        // to do this, we need to figure out the values that define this 
        // capsule.

        // You can think of a capsule as a cylinder with two spheres on either
        // end, where the spheres have the same radius as the cylinder.
        // This means that a capsule can be defined by three values: the 
        // locations of the centres of the two spheres, and the radius.

        // Given that a character collider exposes its total height (including
        // spheres!) and the radius, we can use this to figure out the location
        // of the two capsule points in world-space.

        // The center of the sphere at the top of the controller's capsule
        var capsulePoint1 = transform.position + new Vector3(
            0, (controller.height / 2) - controller.radius, 0);

        // The center of the sphere at the bottom of the controller's capsule
        var capsulePoint2 = transform.position - new Vector3(
            0, (controller.height / 2) + controller.radius, 0);

        // The list of colliders we may be overlapping. We're unlikely to 
        // overlap more than ten colliders, so make the list that long. (Adjust
        // this if you're encountering lots of overlaps.)
        Collider[] overlappingColliders = new Collider[10];

        // Figure out which colliders we're overlapping. We pass in the 
        // overlappingColliders array, and it when this function returns, the 
        // array will be filled with references to other colliders. The function
        // returns the number of colliders that overlap the capsule.
        var overlapCount  = Physics.OverlapCapsuleNonAlloc(
            capsulePoint1, capsulePoint2,  // the centers of the spheres
            controller.radius,  // the radius of the spheres
            overlappingColliders);

        // (Note: we _could_ have used OverlapCapsule, which returns a brand-
        // new array, but that requires the function to allocate the memory
        // for it on the heap. Because we don't use this array after this 
        // function ends, the array would turn into garbage. More garbage means
        // the garbage collector will run more often, which means performance
        // hitches. By creating our own array locally, it's stored on the stack;
        // data on the stack doesn't get turned into garbage when it goes away,
        // but it can't stay around after this function returns, which is fine
        // for this case.)

        // For each item we were told the capsule overlaps...
        for (int i = 0; i < overlapCount; i++) {

            // Get the collider the capsule overlaps
            var overlappingCollider = overlappingColliders[i];

            // If this collider is our controller, ignore it
            if (overlappingCollider == controller)  {
                continue;
            }

            // We need to compute how much movement we need to perform to not
            // overlap this collider.

            // First, define some variables to store the direction and distance.
            Vector3 direction;
            float distance;

            // Next, provide information about both our collider and the other 
            // one. Our direction and distance variables will be filled with 
            // data.
            Physics.ComputePenetration(
                controller,  // our collider
                transform.position, // its position
                transform.rotation, // its orientation
                overlappingCollider, // the other collider
                overlappingCollider.transform.position,  // its position
                overlappingCollider.transform.rotation,  // its orientation
                out direction, // will contain the direction we need to move in
                out distance // will contain the distance we need to move by
            );

            // Don't get pushed vertically; that's what 1. gravity and 2. moving 
            // platforms are for.
            direction.y = 0;

            // Update our position to move out of the way.
            transform.position += direction * distance;

        }

        // Next, we'll handle standing on a moving platform.

        // Cast a ray down to our feet. If it hit a MovingPlatform, inherit its 
        // velocity.

        // (We don't need to worry about avoiding the character controller here,
        // because the raycast starts inside the controller, so it won't hit
        // it.)

        var ray = new Ray(transform.position, Vector3.down);
        RaycastHit hit;

        // The maximum distance we want to look for.
        float maxDistance = (controller.height / 2f) + 0.1f;

        // Cast the ray. Did it hit anything?
        if (Physics.Raycast(ray, out hit, maxDistance)) {

            // It did!

            // Did it have a MovingPlatform component?
            var platform = hit.collider.gameObject
                              .GetComponent<MovingPlatform>();

            if (platform != null) {
                // If it did, update our position based on the platform's
                // current velocity.
                transform.position += platform.velocity * Time.fixedDeltaTime;
            }
        }
    }
}
----

. Add a PlatformRiding component to the object that has your CharacterCollider.

. Play the game, and jump onto an object that has a MovingPlatform component. It will be carried with the platform.

==== Discussion

Discuss how no momentum is being imparted here - if you're on a platform that's moving up quickly, you won't be given a speed boost.

=== Responding to being pushed by objects
// card: https://trello.com/c/4FHm2cjd

==== Problem

You want your character collider to be able to push rigidbodies.

==== Solution

. Create a new C# script called Pushing. Add the following code to it:

// snip: pushing

. Add a Pushing component to the object in your scene that has a CharacterController attached to it.
. Add a cube to the scene, and add a rigidbody to it.
. Play the game, and run into the cube. It will be pushed by the impact.

==== Discussion

Discuss how bodies can apply forces to it.

Discuss the difference between the DirectlySetVelocity and ApplyForces modes.

Discuss when OnControllerColliderHit is called (when a CharacterController moves into another collider), and what information is available in the method's parameters.
