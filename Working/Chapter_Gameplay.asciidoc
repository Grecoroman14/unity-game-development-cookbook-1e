[[chapter_gameplay]]
== Gameplay

=== Introduction

Gameplay comes in many different guises.

=== Managing quests
// card: https://trello.com/c/QzEs0kfB

==== Problem

You want to manage a quest structure, where the player needs to complete certain objectives in order to finish a quest. 

As part of your quest structure, you want some objectives to be optional, and some objectives to not be presented to the player until they're achieved. If an objective is failed, and it isn't optional, then the entire quest is failed.

==== Solution

Before we can manage a quest structure, we need a quest. 

First, let's define a simple quest: we'll position the camera in front of some coloured blocks, and say that the player has to click on them in order to complete the quest. However, one of the blocks is forbidden, and clicking on it will fail the quest.

// image: quests1.png

First, we'll see need to create the scene for our quest:

. Create four cubes, and place them in front of the camera.

. For each of the cubes, create a Material, and add it by dragging and dropping it onto the cube in the Scene View.

. Change the colour of the material for each cube. Make one red, one green, one yellow, and one blue. (If any of these colours are hard to tell apart, change the colours to whatever suits you best.)

// image: quests2.png
// annotation: One of our cubes, showing how it is set up.

. Select the Main Camera, and add a Physics Raycaster to it.

Next, we'll create a canvas that displays the status of the quest and its objectives.

. Create a new canvas.
    . Add a game object with a Text component in it. 
    . Resize this object so that it can comfortably contain a paragraph of text.

Next, we'll set up the type of object that stores information about a quest.

. Create a new C# script called Quest, and add the following code to it:

// snip: quest
[source,csharp]
----
#if UNITY_EDITOR
using UnityEditor;
#endif

// A Quest stores information about a quest: its name, and its objectives.

// CreateAssetMenu makes the Create Asset menu contain an entry that creates
// a new Quest asset.
[CreateAssetMenu(fileName = "New Quest", menuName = "Quest", order = 100)]
public class Quest : ScriptableObject
{

    // Represents the status of objectives and quests
    public enum Status {
        NotYetComplete, // the objective or quest has not yet been completed
        Complete, // the objective or quest has been successfully completed
        Failed // the objective or quest has failed
    }

    // The name of the quest
    public string questName;

    // The list of objectives that form this quest
    public List<Objective> objectives;

    // Objectives are the specific tasks that make up a quest.
    [System.Serializable]
    public class Objective
    {
        // The visible name that's shown the player.
        public string name = "New Objective";

        // If true, this objective doesn't need to be complete in order for
        // the quest to be considered complete.
        public bool optional = false;

        // If false, the objective will not be shown to the user if it's not
        // yet complete. (It will be shown if it's Complete or Failed.)
        public bool visible = true;

        // The status of the objective when the quest begins. Usually this will
        // be "not yet complete", but you might want an objective that starts
        // as Complete, and can be Failed.
        public Status initalStatus = Status.NotYetComplete;
    }

}

#if UNITY_EDITOR
// Draw a custom editor that lets you build the list of objectives.
[CustomEditor(typeof(Quest))]
public class QuestEditor : Editor {

    // Called when Unity wants to draw the Inspector for a Quest.
    public override void OnInspectorGUI()
    {

        // Ensure that the object we're displaying has had any pending changes 
        // done.
        serializedObject.Update();

        // Draw the name of the quest.
        EditorGUILayout.PropertyField(serializedObject.FindProperty("questName"), new GUIContent("Name"));

        // Draw a header for the list of objectives
        EditorGUILayout.LabelField("Objectives");

        // Get the property that contains the list of objectives
        var objectiveList = serializedObject.FindProperty("objectives");

        // Indent the objectives
        EditorGUI.indentLevel += 1;

        // For each objective in the list, draw an entry
        for (int i = 0; i < objectiveList.arraySize; i++)
        {
            // Draw a single line of controls
            EditorGUILayout.BeginHorizontal();

            // Draw the objective itself (its name, and its flags)
            EditorGUILayout.PropertyField(
                objectiveList.GetArrayElementAtIndex(i), 
                includeChildren: true
            );

            // Draw a button that moves the item up in the list
            if (GUILayout.Button("Up", EditorStyles.miniButtonLeft, 
                                 GUILayout.Width(25)))
            {
                objectiveList.MoveArrayElement(i, i - 1);
            }

            // Draw a button that moves the item down in the list
            if (GUILayout.Button("Down", EditorStyles.miniButtonMid, 
                                 GUILayout.Width(40)))
            {
                objectiveList.MoveArrayElement(i, i + 1);
            }

            // Draw a button that removes the item from the list
            if (GUILayout.Button("-", EditorStyles.miniButtonRight, 
                                 GUILayout.Width(25)))
            {
                objectiveList.DeleteArrayElementAtIndex(i);
            }

            EditorGUILayout.EndHorizontal();

        }

        // Remove the indentation
        EditorGUI.indentLevel -= 1;

        // Draw a button at adds a new objective to the list
        if (GUILayout.Button("Add Objective"))
        {
            objectiveList.arraySize += 1;
        }

        // Save any changes
        serializedObject.ApplyModifiedProperties();

    }
}

#endif
----

We can now create a quest.

. Open the Assets menu, and choose Create -> Quest.

. Name the new quest "Click on the Blocks".

. Click "Add Objective".
    . Name the new objective "Click on the red block".
    . Turn on the "Visible" checkbox.

. Repeat this process two more times - one each for the green and yellow blocks.
    . Make one of them optional, and one of them optional and not visible.

. Add one more objective, for the blue block.
    . For this one, set its name to "Don't click on the blue block".
    . Set its Initial Status to "Complete".

When you're done, the Inspector should look something like <<quests-objective-list>>.

img: quests-objective-list

We'll now set up the code that manages the quest.

Create a new C# script called QuestManager, and add the following code to it:

// snip: quest_manager
[source,csharp]
----
// Represents the player's current progress through a quest.
public class QuestStatus {

    // The underlying data object that describes the quest.
    public Quest questData;

    // The map of objective identifiers.
    public Dictionary<int, Quest.Status> objectiveStatuses;

    // The constructor. Pass a Quest to this to set it up.
    public QuestStatus(Quest questData)
    {
        // Store the quest info
        this.questData = questData;

        // Create the map of objective numbers to their status
        objectiveStatuses = new Dictionary<int, Quest.Status>();

        for (int i = 0; i < questData.objectives.Count; i += 1)
        {
            var objectiveData = questData.objectives[i];

            objectiveStatuses[i] = objectiveData.initalStatus;
        }
    }

    // Returns the state of the entire quest.
    // If all non-optional objectives are complete, the quest is complete.
    // If any non-optional objective is failed, the quest is failed.
    // Otherwise, the quest is not yet complete.
    public Quest.Status questStatus {
        get {

            for (int i = 0; i < questData.objectives.Count; i += 1) {

                var objectiveData = questData.objectives[i];

                // Optional objectives do not matter to the overall quest status
                if (objectiveData.optional)
                    continue;

                var objectiveStatus = objectiveStatuses[i];

                // this is a mandatory objective
                if (objectiveStatus == Quest.Status.Failed)
                {
                    // if a mandatory objective is failed, the whole 
                    // quest is failed
                    return Quest.Status.Failed;
                }
                else if (objectiveStatus != Quest.Status.Complete)
                {
                    // if a mandatory objective is not yet complete,
                    // the whole quest is not yet complete
                    return Quest.Status.NotYetComplete;
                }
            }

            // All mandatory objectives are complete, so this quest is complete
            return Quest.Status.Complete;

        }
    }

    // Returns a string containing the list of objectives, their statuses, and
    // the status of the quest.
    public override string ToString()
    {
        var stringBuilder = new System.Text.StringBuilder();

        for (int i = 0; i < questData.objectives.Count; i += 1)
        {
            // Get the objective and its status
            var objectiveData = questData.objectives[i];
            var objectiveStatus = objectiveStatuses[i];

            // Don't show hidden objectives that haven't been finished
            if (objectiveData.visible == false &&
                objectiveStatus == Quest.Status.NotYetComplete)
            {
                continue;
            }

            // If this objective is optional, display "(Optional)" after its name
            if (objectiveData.optional)
            {
                stringBuilder.AppendFormat("{0} (Optional) - {1}\n",
                                           objectiveData.name, 
                                           objectiveStatus.ToString());
            }
            else
            {
                stringBuilder.AppendFormat("{0} - {1}\n", 
                                           objectiveData.name,
                                           objectiveStatus.ToString());
            }

        }

        // Add a blank line followed by the quest status
        stringBuilder.AppendLine();
        stringBuilder.AppendFormat("Status: {0}", this.questStatus.ToString());

        return stringBuilder.ToString();
    }
}

// Manages a quest.
public class QuestManager : MonoBehaviour {

    // The quest that starts when the game starts.
    [SerializeField] Quest startingQuest = null;

    // A label to show the state of the quest in.
    [SerializeField] UnityEngine.UI.Text objectiveSummary = null;

    // Tracks the state of the current quest.
    QuestStatus activeQuest;

    // Start a new quest when the game starts
    void Start () {

        if (startingQuest != null)
        {
            StartQuest(startingQuest);
        }
    }   

    // Begins tracking a new quest
    public void StartQuest(Quest quest) {

        activeQuest = new QuestStatus(quest);

        UpdateObjectiveSummaryText();

        Debug.LogFormat("Started quest {0}", activeQuest.questData.name);
    }

    // Updates the label that displays the status of the quest and 
    // its objectives
    void UpdateObjectiveSummaryText() {


        string label;

        if (activeQuest == null) {
            label = "No active quest.";
        } else {
            label = activeQuest.ToString();
        }

        objectiveSummary.text = label;
    }

    // Called by other objects to indicate that an objective has changed status
    public void UpdateObjectiveStatus(Quest quest, int objectiveNumber, Quest.Status status) {

        if (activeQuest == null) {
            Debug.LogError("Tried to set an objective status, but no quest is active");
            return;
        }

        if (activeQuest.questData != quest) {
            Debug.LogWarningFormat("Tried to set an objective status for " +
                                   "quest {0}, but this is not the active " +
                                   "quest. Ignoring.", quest.questName);
            return;
        }

        // Update the objective status
        activeQuest.objectiveStatuses[objectiveNumber] = status;

        // Update the display label
        UpdateObjectiveSummaryText();
    }


}
----

. Create a new empty game object, and add a +QuestManager+ component to it.
. Drag the Quest asset you created into its Starting Quest field.
. Drag the Text object that you set up earlier into its Objective Summary field.

Next, we'll set up a class that represents a change to an objective's status that can be applied when something happens.

. Create a new C# script called ObjectiveTrigger, and add the following code to it:

// snip: objective_trigger
[source,csharp]
----
#if UNITY_EDITOR
using UnityEditor;
using System.Linq;
#endif

// Combines a quest, an objective in that quest, and an objective status to use.
[System.Serializable]
public class ObjectiveTrigger
{

    // The quest that we're referring to
    public Quest quest;

    // The status we want to apply to the objective
    public Quest.Status statusToApply;

    // The location of this objective in the quest's objective list
    public int objectiveNumber;

    public void Invoke() {
        // Find the quest manager
        var manager = Object.FindObjectOfType<QuestManager>();

        // And tell it to update our objective
        manager.UpdateObjectiveStatus(quest,
                                       objectiveNumber,
                                       statusToApply);
    }
}

#if UNITY_EDITOR
// Custom property drawers override how a type of property appears in 
// the Inspector.
[CustomPropertyDrawer(typeof(ObjectiveTrigger))]
public class ObjectiveTriggerDrawer : PropertyDrawer {

    // Called when Unity needs to draw an ObjectiveTrigger property
    // in the Inspector.
    public override void OnGUI(Rect position, SerializedProperty property, 
                               GUIContent label)
    {
        // Wrap this in Begin/EndProperty to ensure that undo works on the 
        // entire ObjectiveTrigger property
        EditorGUI.BeginProperty(position, label, property);

        // Get a reference to the three properties in the ObjectiveTrigger.
        var questProperty = property.FindPropertyRelative("quest");
        var statusProperty = property.FindPropertyRelative("statusToApply");
        var objectiveNumberProperty = 
            property.FindPropertyRelative("objectiveNumber");

        // We want to display three controls:
        // - An Object field for dropping a Quest object into
        // - A Popup field for selecting a Quest.Status from
        // - A Popup field for selecting the specific objective from; it should
        //   show the name of the objective.
        // If no Quest has been specified, or if the Quest has no objectives,
        // the objective popup should be empty and disabled.

        // Calculate the rectangles in which we're displaying.
        var lineSpacing = 2;

        // Calculate the rectangle for the first line
        var firstLinePosition = position;
        firstLinePosition.height = base.GetPropertyHeight(questProperty, label);

        // And for the second line (same as the first line, but shifted down 
        // one line)
        var secondLinePosition = position;
        secondLinePosition.y = firstLinePosition.y + 
            firstLinePosition.height + lineSpacing;
        secondLinePosition.height = 
            base.GetPropertyHeight(statusProperty, label);

        // Repeat for the third line (same as the second line, but shifted down)
        var thirdLinePosition = position;
        thirdLinePosition.y = secondLinePosition.y + 
            secondLinePosition.height + lineSpacing;
        thirdLinePosition.height = 
            base.GetPropertyHeight(objectiveNumberProperty, label);

        // Draw the quest and status properties, using the automatic
        // property fields
        EditorGUI.PropertyField(firstLinePosition, questProperty, 
                                new GUIContent("Quest"));
        EditorGUI.PropertyField(secondLinePosition, statusProperty, 
                                new GUIContent("Status"));

        // Now we draw our custom property for the objec

        // Draw a label on the left hand side, and get a new rectangle to
        // draw the popup in
        thirdLinePosition = EditorGUI.PrefixLabel(thirdLinePosition, 
                                                  new GUIContent("Objective"));

        // Draw the UI for choosing a property
        var quest = questProperty.objectReferenceValue as Quest;

        // Only draw this if we have a quest, and it has objectives
        if (quest != null && quest.objectives.Count > 0)
        {
            // Get the name of every objective, as an array
            var objectiveNames = quest.objectives.Select(o => o.name).ToArray();

            // Get the index of the currently selected objective
            var selectedObjective = objectiveNumberProperty.intValue;

            // If we somehow are referring to an object that's not present
            // in the list, reset it to the first objective
            if (selectedObjective >= quest.objectives.Count) {
                selectedObjective = 0;
            }

            // Draw the popup, and get back the new selection
            var newSelectedObjective = EditorGUI.Popup(thirdLinePosition, 
                                                       selectedObjective, 
                                                       objectiveNames);

            // If it was different, store it in the property
            if (newSelectedObjective != selectedObjective)
            {
                objectiveNumberProperty.intValue = newSelectedObjective;
            }

        } else {
            // Draw a disabled popup as a visual placeholder
            using (new EditorGUI.DisabledGroupScope(true)) {
                // Show a popup with a single entry: the string "-". Ignore its
                // return value, since it's not interactive anyway.
                EditorGUI.Popup(thirdLinePosition, 0, new[] { "-" });
            }
        }

        EditorGUI.EndProperty();
    }

    // Called by Unity to figure out the height of this property.
    public override float GetPropertyHeight(SerializedProperty property, 
                                            GUIContent label)
    {
        // The number of lines in this property
        var lineCount = 3;

        // The number of pixels in between each line
        var lineSpacing = 2;

        // The height of each line
        var lineHeight = base.GetPropertyHeight(property, label);

        // The height of this property is the number of lines times the height
        // of each line, plus the spacing in between each line
        return (lineHeight * lineCount) + (lineSpacing * (lineCount - 1));
    }
}
#endif 
----

Finally, we'll set up the cubes so that they complete or fail objectives when they're clicked.

. Create a new C# script called TriggerObjectiveOnClick, and add the following code to it:

// snip: trigger_objective_on_click
[source,csharp]
----

using UnityEngine.EventSystems;

// Triggers an objective when an object enters it.
public class TriggerObjectiveOnClick : MonoBehaviour, IPointerClickHandler {

    // The objective to trigger, and how to trigger it.
    [SerializeField] ObjectiveTrigger objective = new ObjectiveTrigger();

    // Called when the player clicks on this object
    void IPointerClickHandler.OnPointerClick(PointerEventData eventData)
    {
        // We just completed or failed this objective!
        objective.Invoke();

        // Disable this component so that it doesn't get run twice
        this.enabled = false;
    }
}
----

. Add a +TriggerObjectiveOnClick+ component to each of the cubes. For each one, drag in the Quest asset into its Quest field, and select the appropriate status that the objective should be set to (that is, set the blue cube to Failed, and the rest to Complete.)

<<quests-objective-trigger>> shows an example of one of the cube's +TriggerObjectiveOnClick+ after it's been configured.

img: quests-objective-trigger

. Play the game. The state of the quest is shown on the screen, and changes as you click on different cubes.

==== Discussion

=== Creating an Inventory Manager

==== Problem

You want to create a system that tracks various quantities of items in the player's possession.

==== Solution

// TODO - STILL DOING THE IMPLEMENTATION OF THIS ONE

==== Discussion




=== Managing hitpoints
// card: https://trello.com/c/gt2ookt5

==== Problem

You want objects to take damage when another kind of object hits them. When they take enough damage, they're destroyed.

==== Solution

Create a script that can receive a signal that it has taken damage, and has an amount of 'hit points' that can be diminished.

. Create a new C# script called "DamageReceiver", and add the following code to it:

// snip: damage_receiver
[source,csharp]
----
public class DamageReceiver : MonoBehaviour {

    UnityEngine.Events.UnityEvent onDeath;

    [SerializeField] int hitPoints = 5;

    int currentHitPoints;

    private void Awake()
    {
        currentHitPoints = hitPoints;
    }

    public void TakeDamage(int damageAmount)
    {
        currentHitPoints -= damageAmount;

        if (currentHitPoints <= 0) {
            if (onDeath != null) {
                onDeath.Invoke();
            }

            Destroy(gameObject);
        }
    }
}
----

Next, create a script that detects if it has collided with another; if that other object has a +DamageReceiver+ on it, it is told it has taken damage.

. Create a new C# script called "DamageGiver", and add the following code to it:

// snip: damage_giver
[source,csharp]
----
public class DamageGiver : MonoBehaviour {

    [SerializeField] int damageAmount = 1;

    // Called when the object collides with another
    private void OnCollisionEnter(Collision collision)
    {
        // Does the object we hit have a damage receiver?

        var otherDamageReceiver = collision
            .gameObject.GetComponent<DamageReceiver>();

        if (otherDamageReceiver != null) {

            // Tell it to take damage.
            otherDamageReceiver.TakeDamage(damageAmount);
        }

        // Destroy this projectile
        Destroy(gameObject);

    }
}
----

To test this, we'll create a script that creates and emits projectiles.

. Create a new C# script called "ProjectileShooter", and add the following code to it:

// snip: projectile_shooter
[source,csharp]
----
public class ProjectileShooter : MonoBehaviour {

    // The projectile to instantiate copies of
    [SerializeField] GameObject projectilePrefab = null;

    // The amount of time to wait before creating another projectile
    [SerializeField] float timeBetweenShots = 1;

    // The speed that new projectiles should be moving at
    [SerializeField] float projectileSpeed = 10;

    // On start, begin shooting projectiles
	void Start () {
        // Start creating projectiles
        StartCoroutine(ShootProjectiles());
	}

    // Loop forever, creating a projectile every 'timeBetweenShots' seconds
    IEnumerator ShootProjectiles() {
        while (true) {
            ShootNewProjectile();

            yield return new WaitForSeconds(timeBetweenShots);
        }
    }

    // Creates a new projectile and starts it moving
    void ShootNewProjectile() {

        // Spawn the new object with the emitter's position and rotation
        var projectile = Instantiate(
            projectilePrefab,
            transform.position,
            transform.rotation
        );

        // Get the rigidbody on the new projectile
        var rigidbody = projectile.GetComponent<Rigidbody>();

        if (rigidbody == null) {
            Debug.LogError("Projectile prefab has no rigidbody!");
            return;
        }

        // Make it move away from the emitter's forward direction at 
        // 'projectileSpeed' units per second
        rigidbody.velocity = transform.forward * projectileSpeed;

        // Get both the projectile's collider, and the emitter's collider
        var collider = projectile.GetComponent<Collider>();
        var myCollider = this.GetComponent<Collider>();

        // If both of them are valid, tell the physics system to ignore 
        // collisions between them (to prevent projectiles from colliding with
        // their source)
        if (collider != null && myCollider != null) {
            Physics.IgnoreCollision(collider, myCollider);
        }

    }
}
----

Finally, we'll set up some objects that demonstrate the system in action.

. Create a cube, name it "Damage Receiver", and attach the +DamageReceiver+ script to it.

. Create a sphere, and name it "Projectile".
    . Attach a Rigidbody to it. Disable gravity on the Rigidbody.
    . Attach a +DamageGiver+ component to it.
    . Drag the sphere from the Hierarchy into the Project tab. This will create a prefab.
    . Delete the original sphere from the scene.

. Create a cylinder, and name it "Shooter".
    . Attach a +ProjectileShooter+ script to it.
        . Drag the "Projectile" prefab into its Projectile Prefab field.
    . Position and orient the cylinder so that its forward direction - that is, its blue arrow - is aimed at the damage receiver.

. Start the game. The shooter will fire spheres at the target; after enough hit it, it will be removed from the scene.

==== Discussion


=== Creating a top-down camera
// card: https://trello.com/c/MJK2nm9w

==== Problem

You want to create a camera system that looks down at the world. You want to be able to move the camera around, and you want to limit the range that it can move around in.

==== Solution

Top-down cameras usually look best when they're looking down at an angle, not when they're aiming straight down the Y axis. However, we want the camera to move around only on the X and Z directions, parallel to the ground. 

. Create an empty game object, and call it Camera Rig.
. Move the Main Camera into the Camera Rig.
. Set the local position of the Main Camera to (0,0,0), so that it's at the same location as the Camera Rig.
. Rotate the camera (not the camera rig!) around the X axis so that it's looking down at the world.

Next, we'll add the code that moves the camera.

. Create a new C# script called TopDownCamera.cs, and add the following code to it:

// snip: top_down_camera
[source,csharp]
----
// Allows for limited top-down movement of a camera.
public class TopDownCameraMovement : MonoBehaviour {

    // The speed that the camera will move, in units per second
    [SerializeField] float movementSpeed = 20;

    // The lower-left position of the camera, on its current X-Z plane.
    [SerializeField] Vector2 minimumLimit = -Vector3.one;

    // The upper-right position of the camera, on its current X-Z plane.
    [SerializeField] Vector2 maximumLimit = Vector3.one;

    // Every frame, update the camera's position
    void Update()
    {
        // Get how much the user wants to move the camera
        var horizontal = Input.GetAxis("Horizontal");
        var vertical = Input.GetAxis("Vertical");

        // Compute how much movement we want to apply this frame, in world-space.
        var offset = new Vector3(horizontal, 0, vertical) 
            * Time.deltaTime * movementSpeed;

        // Figure out what our new position would be.
        var newPosition = transform.position + offset;

        // Is this new position within our permitted bounds?
        if (bounds.Contains(newPosition)) {
            // Then move to it.
            transform.position = newPosition;
        } else {
            // Otherwise, figure out the closest point to the boundary, and
            // move there instead.
            transform.position = bounds.ClosestPoint(newPosition);
        }
    }

    // Computes the bounding box that the camera is allowed to be in.
    Bounds bounds {
        get {

            // We'll create a bounding box that's zero units high,
            // and positioned at the current height of the camera.
            var cameraHeight = transform.position.y;

            // Figure out the position of the corners of the boxes in world-space
            Vector3 minLimit = new Vector3(minimumLimit.x, cameraHeight, minimumLimit.y);
            Vector3 maxLimit = new Vector3(maximumLimit.x, cameraHeight, maximumLimit.y);

            // Create a new Bounds using these values and return it
            var newBounds = new Bounds();
            newBounds.min = minLimit;
            newBounds.max = maxLimit;

            return newBounds;
        }
    }

    // Draw the bounding box.
    private void OnDrawGizmos()
    {
        Gizmos.color = Color.red;

        Gizmos.DrawWireCube(bounds.center, bounds.size);
    }
}
----

. Attach a TopDownCamera script to the Camera Rig.
. A red rectangle will appear on the same level as the camera (see <<top-down-camera-positioning>>). Adjust the minimum and maximum points in the Inspector so that they cover the area that you want the camera to move around in.

img: top-down-camera-positioning

. Play the game. The camera will move when you press the arrow keys, and won't leave the red rectangle. If the camera is outside the rectangle before the game starts, it will move inside it.

==== Discussion

=== Dragging a box to select objects
// card: https://trello.com/c/9T9fgHyS

==== Problem

You want to be able to click and drag the mouse to create a visible rectangle on screen. When you release the mouse, you want to know which objects were inside that rectangle.

==== Solution

First, we'll create the canvas that draws the box, and the box object itself.

. Open the GameObject menu, and choose UI -> Canvas.
. Open the GameObject menu again, and choose UI -> Image.
. Name the new Image "Selection Box".

Next, we'll create a script that can be told about when it's selected. 

. Create a new C# script called BoxSelectable, and add the following code to it:

// snip: box_selectable
[source,csharp]
----
// Handles the input and display of a selection box.
public class BoxSelectable: MonoBehaviour {

    public void Selected() {

        Debug.LogFormat("{0} was selected!", gameObject.name);

    }

}
----

. Create some objects - it doesn't matter what they are, cubes will do - and place them somewhere that the camera can see them.
    . Add a +BoxSelectable+ script to each of them.

Next, we'll create the script that updates the position and size of the selection box, and reports on which objects were selected.

. Create a new C# script called BoxSelection, and add the following code to it:

// snip: box_selection
[source,csharp]
----
// Handles the input and display of a selection box.
public class BoxSelection : MonoBehaviour
{

    // Draggable inspector reference to the Image GameObject's RectTransform.
    public RectTransform selectionBox;

    // This variable will store the location of wherever we first click before dragging.
    private Vector2 initialClickPosition = Vector2.zero;

    // The rectangle that the box has dragged, in screen space.
    public Rect SelectionRect { get; private set; }

    // If true, the user is actively dragging a box
    public bool IsSelecting { get; private set; }

    // Configure the visible box
    private void Start()
    {
        // Setting the anchors to be positioned at zero-zero means that
        // the box's size won't change as its parent changes size
        selectionBox.anchorMin = Vector2.zero;
        selectionBox.anchorMax = Vector2.zero;

        // Setting the pivot point to zero means that the box will pivot around
        // its lower-left corner
        selectionBox.pivot = Vector2.zero;

        // Hide the box at the start
        selectionBox.gameObject.SetActive(false);
    }

    void Update()
    {
        // When we start dragging, record the position of the mouse, and start
        // showing the box
        if (Input.GetMouseButtonDown(0))
        {
            // Get the initial click position of the mouse. No need to convert to GUI space
            // since we are using the lower left as anchor and pivot.
            initialClickPosition = new Vector2(Input.mousePosition.x, Input.mousePosition.y);

            // Show the box
            selectionBox.gameObject.SetActive(true);
        }

        // While we are dragging, update the position and size of the box based
        // on the mouse position
        if (Input.GetMouseButton(0))
        {
            // Store the current mouse position in screen space.
            Vector2 currentMousePosition = new Vector2(Input.mousePosition.x, Input.mousePosition.y);

            // Figure out the lower-left corner, and the upper-right corner
            var xMin = Mathf.Min(currentMousePosition.x, initialClickPosition.x);
            var xMax = Mathf.Max(currentMousePosition.x, initialClickPosition.x);
            var yMin = Mathf.Min(currentMousePosition.y, initialClickPosition.y);
            var yMax = Mathf.Max(currentMousePosition.y, initialClickPosition.y);

            // Build a rectangle from these corners
            var screenSpaceRect = Rect.MinMaxRect(xMin, yMin, xMax, yMax);

            // The anchor of the box has been configured to be its lower-left
            // corner, so by setting its anchoredPosition, we set its lower-left
            // corner.
            selectionBox.anchoredPosition = screenSpaceRect.position;

            // The size delta is how far the box extends from its anchor.
            // Because the anchor's minimum and maximum are the same point,
            // changing its size delta directly changes its final size.
            selectionBox.sizeDelta = screenSpaceRect.size;

            // Update our selection box
            SelectionRect = screenSpaceRect;

        }

        // When we release the mouse button, hide the box, and record that we're
        // no longer selecting
        if (Input.GetMouseButtonUp(0))
        {
            SelectionComplete();

            // Hide the box
            selectionBox.gameObject.SetActive(false);

            // We're no longer selecting
            IsSelecting = false;
        }
    }

    // Called when the user finishes dragging a selection box.
    void SelectionComplete()
    {

        // Get the component attached to this scene
        Camera mainCamera = GetComponent<Camera>();

        // Get the bottom-left and top-right corners of the screen-space
        // selection view, and convert them to viewport space
        var min = mainCamera.ScreenToViewportPoint(
            new Vector3(SelectionRect.xMin, SelectionRect.yMin));
        var max = mainCamera.ScreenToViewportPoint(
            new Vector3(SelectionRect.xMax, SelectionRect.yMax));

        // We want to create a bounding box in viewport space. We have the X and
        // Y coordinates of the bottom-left and top-right corners; now we'll 
        // include the Z coordinates.
        min.z = mainCamera.nearClipPlane;
        max.z = mainCamera.farClipPlane;

        // Construct our bounding box
        var viewportBounds = new Bounds();
        viewportBounds.SetMinMax(min, max);

        // Check each object that has a Selectable component
        foreach (var selectable in FindObjectsOfType<BoxSelectable>()) {

            // Figure out where this object is in viewport space
            var viewportPoint = mainCamera.WorldToViewportPoint(selectable.transform.position);

            // Is that point within our viewport bounding box? If it is, they're
            // selected.
            var selected = viewportBounds.Contains(viewportPoint);

            if (selected) {
                // Let them know.            
                selectable.Selected();
            }
        }

    }
}
----

. Attach a +BoxSelection+ component to the main camera.
    . Drag the "Selection Box" onto the Selection Box field.

. Run the game. You can click and drag to create the box; when you release the mouse, all objects within the rectangle that have a +BoxSelectable+ component will log that they were selected.

==== Discussion

If you use a sliced sprite, your selection box can have borders.

Discuss viewport space here.

=== Creating a menu structure
// card: https://trello.com/c/f9ChPe5k

==== Problem

You want to create a collection of menu pages, in which only one menu is visible at a time.

==== Solution

. Create a new script called +Menu+:

// snip: menu
[source,csharp]
----
// Contains UnityEvent, which this script uses
using UnityEngine.Events; 

public class Menu : MonoBehaviour {

    // Invoked when a menu appears on screen.
	public UnityEvent menuDidAppear = new UnityEvent();

	// Invoked when a menu is removed from the screen.
	public UnityEvent menuWillDisappear = new UnityEvent();

}
----

. Create a new script called +MenuManager+:

// snip: menu_manager
[source,csharp]
----
public class MenuManager : MonoBehaviour {

	[SerializeField] List<Menu> menus = new List<Menu>();

	private void Start()
	{
		// Show the first menu on start
		ShowMenu(menus[0]);
	}

	public void ShowMenu(Menu menuToShow) {

        // Ensure that this menu is one that we're tracking.
		if (menus.Contains(menuToShow) == false) {

			Debug.LogErrorFormat(
				"{0} is not in the list of menus", 
				menuToShow.name
			);
			return;
		}

        // Enable this menu, and disable the others
		foreach (var otherMenu in menus) {

            // Is this the menu we want to display?
			if (otherMenu == menuToShow) {

                // Mark it as active
				otherMenu.gameObject.SetActive(true);                

                // Tell the Menu object to invoke its "did appear" action
				otherMenu.menuDidAppear.Invoke();

			} else {

                // Is this menu currently active?
				if (otherMenu.gameObject.activeInHierarchy)
                {
					// If so, tell the Menu object to invoke its "will disappear" action
                    otherMenu.menuWillDisappear.Invoke();
                }

                // And mark it as inactive
				otherMenu.gameObject.SetActive(false);    
			}
		}
	}

    // BEGIN-HIDE
	public void PlayGame() {
		Debug.Log("Starting the game!");
	}

	public void OptionChanged() {
		Debug.Log("Option changed!");
	}
    // END-HIDE
}

----

Next, we'll create a sample menu. It'll have two screens: a main menu, and an options menu.

. Create a new game object, and call it Menu Manager. Add a +MenuManager+ script to it.

. Create a canvas.

. Create a new child game object called "Main Menu". This will act as a container for the menu's controls.

    . Add a Menu script to this object.
    . Add a button game object to the Main Menu. Name this button "Show Options Menu Button". 
    . Set its Text to say "Options Menu". 

. Duplicate the "Main Menu" object, and rename it to "Options Menu".

    . Rename its "Show Options Menu Button" to "Show Main Menu Button".
    . Change its text to say "Back". 

. Select the Menu Manager
. Drag the Main Menu onto the Menus slot.
. Drag the Options Menu onto the Menus slot.

Next, we'll make the buttons show the appropriate menus.

. Select the "Show Options Menu Button" inside the Main Menu.

    . Add a new entry in the button's On Click event.
    . Drag the Menu Manager into the object field.
    . In the Function drop-down menu, choose MenuManager -> ShowMenu.
    . Drag the Options Menu object into the parameter field.
    . When you're done, the On Click event should look like <<menu-manager-show-options-onclick>>.

img: menu-manager-show-options-onclick

. Select the "Show Main Menu Button" inside the Options Menu.

    . Add a new entry in the button's On Click event.
    . Drag the Menu Manager into the object field.
    . In the Function drop-down menu, choose MenuManager -> ShowMenu.
    . Drag the Main Menu object into the parameter field.
    . When you're done, the On Click event should look like <<menu-manager-show-main-onclick>>.

img: menu-manager-show-options-onclick

. Run the game. The main menu will appear; clicking the options button will hide it and show the options menu, and clicking the Back button will return you to the main menu.

==== Discussion

Discuss how you can add other function calls to each +Menu+; <<menu-manager-menu-events>>

img: menu-manager-menu-events


=== Creating a wheeled vehicle
// card: https://trello.com/c/CBS1ZmaA

==== Problem 

You want to implement a vehicle with wheels, like a car.

==== Solution 

. Create an empty object called "Vehicle".
. Add a Rigid Body to it.

    . Set its Mass to 750.
    . Set its Drag to 0.1.

. If you have a car mesh to use, add it as a child of the Vehicle object
    . If you don't have a mesh, add a cube as a child and scale it so that it's the right shape and size of a car. If you do this, make sure you remove the Box collider that comes with the cube.
    . In either case, make sure that your visible object's position is (0,0,0), so that it's in the right 

. Create an empty game object as a child, call it "Colliders"

    . Add an empty game object to "Colliders"; name it "Body".
    . Add a Box Collider to the "Body" object.
    . Click Edit Collider, and click and drag the box so that it fits closely around the visible car object.

. Create a new empty child object of "Colliders", and name it "Wheel Front Left".

    . Add a Wheel Collier to this new object.
    . Position this near where you want the front-left tire to be. If you're using a car mesh, place it in the middle of the visible tire.
    . Adjust the Radius of the wheel to the size you want. (It's okay if the wheel collider goes inside the Body collider.)

. Duplicate the wheel three times - one for each of the other three tires. Move each to one of the other tires, and rename them appropriately. When you're done, the colliders should look something like <<vehicle-wheel-placement>>

img: vehicle-wheel-placement

. Create a new script, and call it Vehicle. Add the following code to it:

// snip: vehicle
[source,csharp]
----
// Configures a single wheel's control parameters.
[System.Serializable]
public class Wheel {
	// The collider this wheel uses
	public WheelCollider collider;

    // Whether this wheel should be powered by the engine
	public bool powered;

    // Whether this wheel is steerable
	public bool steerable;

    // Whether this wheel can apply brakes
	public bool hasBrakes;
}

// Controls the power, braking and steering applied to wheels.
public class Vehicle : MonoBehaviour {

    // The list of wheels on this vehicle
	[SerializeField] Wheel[] wheels = {};

	// The settings used for controlling the wheels:

    // Maximum motor torque
	[SerializeField] float motorTorque = 1000;

    // Maximum brake torque
	[SerializeField] float brakeTorque = 2000;

    // Maximum steering angle
	[SerializeField] float steeringAngle = 45;

	private void Update() {

        // If the Vertical axis is positive, apply motor torque and no brake torque.
        // If it's negative, apply brake torque and no motor torque.
		var vertical = Input.GetAxis("Vertical");

		float motorTorqueToApply;
		float brakeTorqueToApply;

		if (vertical >= 0) {
			motorTorqueToApply = vertical * motorTorque;
			brakeTorqueToApply = 0;
		} else {
			// If the vertical axis is negative, cut the engine and step on the
            // brakes.

            // We use Mathf.Abs here to ensure that we use the positive value
            // of 'vertical' (because applying negative braking torque would
            // lead to weirdness.)
			motorTorqueToApply = 0;
			brakeTorqueToApply = Mathf.Abs(vertical) * brakeTorque;
		}

        // Scale the maximum steering angle by the horizontal axis.
		var currentSteeringAngle = Input.GetAxis("Horizontal") * steeringAngle;

        // Update all wheels

        // Using a for loop, rather than a foreach loop, because foreach loops
        // allocate temporary memory, which is turned into garbage at the end of
        // the frame. We want to minimise garbage, because the more garbage that
        // gets generated, the more often the garbage collector has to run, which
        // causes performance problems.
		for (int wheelNumber = 0; wheelNumber < wheels.Length; wheelNumber++) {

            var wheel = wheels[wheelNumber];

            // If a wheel is powered, it updates its motor torque
			if (wheel.powered) {
				wheel.collider.motorTorque = motorTorqueToApply;
			}

            // If a wheel is steerable, it updates its steer angle
			if (wheel.steerable) {
				wheel.collider.steerAngle = currentSteeringAngle;
			}

            // If a wheel has brakes, it updates its brake torque
			if (wheel.hasBrakes) {
				wheel.collider.brakeTorque = brakeTorqueToApply;
			}
		}
	}
}
----

. Select the "Vehicle" object, and add 4 entries to the Wheels list.
. For each of the entries:
    . Add one of the wheel colliders.
    . If it's a rear wheel, turn on Powered.
    . If it's a front wheel, turn on Steerable.
    . Turn on Has Brakes.

. Play the game. You should be able to drive the car around.

==== Discussion 

Consider adding an orbiting camera to follow the vehicle as it moves.

Consider what happens when all of the wheels are steerable, or all of them are powered.

Modify the mass of the vehicle, or the torque values.

Wheel colliders define their own suspension paramters. Play with them.


=== Keeping a car from tipping over
// card: https://trello.com/c/cPcw2cbK

==== Problem

You want your car to not flip over when doing sharp turns.

==== Solution

Your car tips over because it's rotating around its center of mass, which is too high up. When the center of mass is lower, any rotation around it will force the wheels into the ground harder, instead of flipping the entire car over.

. Create a new C# script called +AdjustCenterOfMass+, with the following code:

// snip: adjust_center_of_mass
[source,csharp]
----
[RequireComponent(typeof(Rigidbody))]
public class AdjustCenterOfMass : MonoBehaviour {

	// How far the center of mass should be moved from its default position
    [SerializeField] Vector3 centerOfMass = Vector3.zero;

	private void Start()
    {
        // Override the center of mass, to enhance stability
        GetComponent<Rigidbody>().centerOfMass += centerOfMass;
    }

	// Called by the editor to show 'gizmos' in the Scene view. Used to help
    // visualise the overriden center of mass.
    private void OnDrawGizmosSelected()
    {
        // Draw a green sphere where the updated center of mass will be.
        Gizmos.color = Color.green;

        var currentCenterOfMass = this.GetComponent<Rigidbody>().worldCenterOfMass;
        Gizmos.DrawSphere(currentCenterOfMass + centerOfMass, 0.125f);
    }
}
----

. Add this component to the game object containing your vehicle's rigid body.

. Move the Center of Mass's Y coordinate down a bit, so that it's just at the floor of the vehicle. The lower the center of mass, the more stable the vehicle will be.

==== Discussion

Discuss how rigidbodies usually compute their center of mass from their colliders, but you can override it

Discuss how it's less realistic but makes for better gameplay

(in real life a car's center of mass is low beacuse of heavy objects like the transmission and engine being under the floor)


=== Creating speed boosts
// card: https://trello.com/c/Z744jhZo

==== Problem

You want to create objects on your race track that give a temporary speed boost to vehicles that drive over them.

==== Solution

First, create the visible component of the speed boost. In this example, we'll go for a simple, cartoonish look.

. Create a new Material, and call it Speed Boost.
    . Set its Albedo colour to red.

. Open the GameObject menu, and choose 3D Object -> Plane. 
    . Position and scale the object appropriately on your track. 
    . Name the object "Speed Boost".
    . Drag the Speed Boost material onto it.
    . Remove the Mesh Collider from the object.
    . Add a Box Collider.
        . Turn on Is Trigger.
        . Adjust the size and position so that it creates a volume big enough for a car (for example, <<racing-speed-boost>>)

img: racing-speed-boost


. Create a new C# script called SpeedBoost, and add the following code to it:

// snip: speed_boost
[source,csharp]
----
public class SpeedBoost : MonoBehaviour {

    // The amount of time the boost should apply
    [SerializeField] float boostDuration = 1;

    // The amount of force to apply in the forward direction
    [SerializeField] float boostForce = 50;

    // Called when a rigidbody enters the trigger
    private void OnTriggerEnter(Collider other)
    {
        // Ensure this collider has a rigidbody, either on itself
        // or on a parent object
        var body = other.GetComponentInParent<Rigidbody>();

        if (body == null) {
            return;
        }

        // Attach a ConstantForce component to it
        var boost = body.gameObject.AddComponent<ConstantForce>();

        // Make the ConstantForce boost the object forward by the specified
        // amount
        boost.relativeForce = Vector3.forward * boostForce;

        // Remove this ConstantForce after boostDuration seconds
        Destroy(boost, boostDuration);
    }
}
----

. Attach a +SpeedBoost+ component to the speed boost object.

. Test the game. When a vehicle enters the boost area, it will be boosted forward for a short duration.

==== Discussion


=== Creating a camera that orbits around its target
// card: https://trello.com/c/3PrteZ6M

==== Problem

You want to create a camera that rotates around a target's position at a fixed distance (sometimes referred to as a "chase camera".)

==== Solution

. Add a camera to the scene

. Create a new C# script called +OrbitingCamera+

. Replace its code with the following:

// snip: orbiting_camera
[source,csharp]
----
public class OrbitingCamera : MonoBehaviour
{

    // The object we're orbiting around
	[SerializeField] Transform target;

    // The speed at which we change our rotation and elevation
	[SerializeField] float rotationSpeed = 120.0f;
	[SerializeField] float elevationSpeed = 120.0f;

    // The minimum and maximum angle of elevation
	[SerializeField] float elevationMinLimit = -20f;
	[SerializeField] float elevationMaxLimit = 80f;

    // The distance we're at from the target
	[SerializeField] float distance = 5.0f;
	[SerializeField] float distanceMin = .5f;
	[SerializeField] float distanceMax = 15f;

    // The angle at which we're rotated around the target
	float rotationAroundTarget = 0.0f;

    // The angle at which we're looking down or up at the target
	float elevationToTarget = 0.0f;

    // When true, the camera will adjust its distance when there's a collider 
	// between it and the target
	[SerializeField] bool clipCamera;

    // Use this for initialization
    void Start()
    {
        Vector3 angles = transform.eulerAngles;
        rotationAroundTarget = angles.y;
        elevationToTarget = angles.x;

		if (target) {
			// Take the current distance from the camera to the target
			float currentDistance = (transform.position - target.position).magnitude;

            // Clamp it to our required minimum/maximum
			distance = Mathf.Clamp(currentDistance, distanceMin, distanceMax);
		}
    }

	// Every frame, after all Update() functions are called, update the camera
    // position and rotation
    //
    // We do this in LateUpdate so that if the object we're tracking has its 
	// position changed in the Update method, the camera will be correctly
	// positioned, because LateUpdate is always run afterwards.
    void LateUpdate()
    {
        if (target)
        {
			// Update our rotation and elevation based on mouse movement
            rotationAroundTarget += 
				Input.GetAxis("Mouse X") * rotationSpeed * distance * 0.02f;

            elevationToTarget -= 
				Input.GetAxis("Mouse Y") * elevationSpeed * 0.02f;

            // Limit the elevation to between the minimum and the maximum
            elevationToTarget = ClampAngle(
				elevationToTarget, 
                elevationMinLimit, 
				elevationMaxLimit
			);

			// Compute the rotation based on these two angles
            Quaternion rotation = Quaternion.Euler(
				elevationToTarget, 
				rotationAroundTarget, 
				0
			);

			// Update the distance based on mouse movement
			distance = distance - Input.GetAxis("Mouse ScrollWheel") * 5;

            // And limit it to the minimum and maximum
            distance = Mathf.Clamp(distance, distanceMin, distanceMax);

            // Figure out a position that's 'distance' units away from the target
			// in the reverse direction to where we're looking
            Vector3 negDistance = new Vector3(0.0f, 0.0f, -distance);
            Vector3 position = rotation * negDistance + target.position;

			if (clipCamera) {

                // We'll cast out a ray from the target to the position we just
                // computed. If the ray hits something, we'll update our position
                // to where the ray hit.

                // Store info about any hit in here.
				RaycastHit hitInfo;

                // Generate a ray from the target to the camera
                var ray = new Ray(target.position, position - target.position);

				// Perform the ray cast; if it hit anything, it returns true,
                // and updates the hitInfo variable
                var hit = Physics.Raycast(ray, out hitInfo, distance);

				if (hit) {
					// We hit something. Update the camera position to where
                    // the ray hit an object.
					position = hitInfo.point;
				}
			}

            // Update the position 
			transform.position = position;

            // Update the rotation so we're looking at the target
            transform.rotation = rotation;            
        }
    }

    // Clamps an angle between 'min' and 'max', wrapping it if it's less than
    // 360 degrees or higher than 360 degrees.
    public static float ClampAngle(float angle, float min, float max)
    {

        // Wrap the angle at -360 and 360
        if (angle < -360F)
            angle += 360F;
        if (angle > 360F)
            angle -= 360F;

        // Clamp this wrapped angle
        return Mathf.Clamp(angle, min, max);
    }
}
----

. Add a cube to the scene.
. Select the camera, and drag the cube's entry in the hierarchy into the +target+ field.
. Run the game. As you move the mouse, the camera will rotate around the target.

==== Discussion

=== Creating orbiting cameras that won't clip through walls
// card: https://trello.com/c/RCcebmcr

==== Problem

You want to detect when there's an object between the camera and the target, and move the camera closer.

==== Solution

Add the following variable to the orbiting camera class:

// snip: orbiting_camera_clip_variables
[source,csharp]
----
    // When true, the camera will adjust its distance when there's a collider 
	// between it and the target
	[SerializeField] bool clipCamera;
----

Next, add the following code to the class' +LateUpdate+ method:

// snip: orbiting_camera_clip_code context:5
[source,csharp]
----
			if (clipCamera) {

                // We'll cast out a ray from the target to the position we just
                // computed. If the ray hits something, we'll update our position
                // to where the ray hit.

                // Store info about any hit in here.
				RaycastHit hitInfo;

                // Generate a ray from the target to the camera
                var ray = new Ray(target.position, position - target.position);

				// Perform the ray cast; if it hit anything, it returns true,
                // and updates the hitInfo variable
                var hit = Physics.Raycast(ray, out hitInfo, distance);

				if (hit) {
					// We hit something. Update the camera position to where
                    // the ray hit an object.
					position = hitInfo.point;
				}
			}
----

Turn on Clip Camera on your Orbiting Camera. The camera will now move closer to the target if there's a collider between the camera and the target.

==== Discussion

Raycasts will only hit colliders, if there's an object that blocks the camera but doesn't have a collider attached, the script won't know to move closer.

=== Detecting when the player has completed a lap
// card: https://trello.com/c/o7kSGKJc

==== Problem

You want to detect when the player has completed a lap around a race circuit. You also want to detect if the player is going the wrong way, or if the player is cheating by taking too much of a shortcut.

==== Solution

You can solve this by creating a set of checkpoints that the player must pass, in order. If the player is passing checkpoints in the wrong order, they're going the wrong way.

. Start by laying out your track, so that both you and the player will know the path they need to take. See <<lap-tracking-track>>.

img: lap-tracking-track

. Add a vehicle to the scene, and ensure that you're able to drive around (just to make sure that the driving component works.)

. Create a new C# script called Checkpoint, and add the following code to it. Note that it contains two classes - one of them is special editor-only code that adds buttons to the Inspector to help build the track.

// snip: checkpoint
[source,csharp]
----
#if UNITY_EDITOR
// Include the UnityEditor namespace when this class is being used in the Editor.
using UnityEditor;
#endif

public class Checkpoint : MonoBehaviour
{

    // If true, this is the start of the circuit
	[SerializeField] public bool isLapStart;

    // The next checkpoint in the circuit. If we're visiting these in reverse, 
    // or skipping too many, then we're going the wrong way.
	[SerializeField] public Checkpoint next;

    // The index number, used by LapTracker to figure out if we're going the
    // wrong way.
	internal int index = 0;

    // Checkpoints are invisible, so we draw a marker in the scene view to make it
    // easier to visualise.
	private void OnDrawGizmos()
	{
		// Draw the markers as a blue sphere, except for the lap start, which 
		// is yellow.
		if (isLapStart)
		{
			Gizmos.color = Color.yellow;
		}
		else
		{
			Gizmos.color = Color.blue;
		}

		Gizmos.DrawSphere(transform.position, 0.5f);

        // If we have a next node set up, draw a blue line to it.
		if (next != null)
		{
			Gizmos.color = Color.blue;
        	Gizmos.DrawLine(transform.position, next.transform.position);
		}
	}
}

#if UNITY_EDITOR
// Code that adds additional controls for building a track to the Checkpoint inspector.
[CustomEditor(typeof(Checkpoint))]
public class CheckpointEditor : Editor {

    // Called when Unity needs to display the Inspector for this Checkpoint
    // component.
	public override void OnInspectorGUI()
	{
        // First, draw the Inspector contents that we'd normally get.
		DrawDefaultInspector();

        // Get a reference to the Checkpoint component we're editing, by casting
		// 'target' (which is just an Object) to Checkpoint.
		var checkpoint = this.target as Checkpoint;

        // Display a button that inserts a new checkpoint between us and the 
		// next one. GUILayout.Button both displays the button, and returns true
        // if it was clicked.
		if (GUILayout.Button("Insert Checkpoint")) {

            // Make a new object, and add a Checkpoint component to it
			var newCheckpoint = new GameObject("Checkpoint")
				.AddComponent<Checkpoint>();

			// Make it point to our next one, and make ourself point to it
			// (in other words, insert it between us and our next checkpoint)
            newCheckpoint.next = checkpoint.next;
            checkpoint.next = newCheckpoint;

            // Make it one of our siblings
			newCheckpoint.transform.SetParent(checkpoint.transform.parent, true);

			// Position it as our next sibling in the hierarchy.
            // Not technically needed, and doesn't affect the game at all,
			// but it looks nicer.
			var nextSiblingIndex = checkpoint.transform.GetSiblingIndex() + 1;
			newCheckpoint.transform.SetSiblingIndex(nextSiblingIndex);

            // Move it slightly so that it's visibly not the same one
            newCheckpoint.transform.position = 
				checkpoint.transform.position + new Vector3(1, 0, 0);

            // Select it, so that we can immediately start moving it
			Selection.activeGameObject = newCheckpoint.gameObject;
		}

		// Disable this button if we don't have a next checkpoint, or if the
		// next checkpoint is the lap start

		var disableRemoveButton = checkpoint.next == null || 
		                                    checkpoint.next.isLapStart;

		using (new EditorGUI.DisabledGroupScope(disableRemoveButton)) {
			// Display a button that removes the next checkpoint
			if (GUILayout.Button("Remove Next Checkpoint"))
            {
                // Get the node that this next checkpoint was linking to
                var next = checkpoint.next.next;

                // Remove the next one
                DestroyImmediate(checkpoint.next.gameObject);

                // Aim ourselves at what it was pointing at
                checkpoint.next = next;
            }
		}		      
	}    
}
#endif
----

. Create a new empty game object called "Checkpoints".

. Add a new empty game object as a child of Checkpoints. Name it "Checkpoint", and add a Checkpoint component to it.
. Position this checkpoint at the start of the racetrack.
. Turn on Is Lap Start.
. Click Insert Checkpoint in the Inspector. A new checkpoint will be added and selected. Position it further along the track.
. Continue inserting new checkpoints. You can also select an earlier checkpoint and click Insert Checkpoint to insert a new checkpoint between two existing points, or delete a checkpoint by selecting the previous checkpoint and clicking Delete Next Checkpoint.
. When you've completed the circuit, select the last checkpoint and drag the lap start checkpoint (the one with a yellow marker) into its Next field.


NOTE: If the connections between checkpoints get messed up, you can fix it by changing the Next field on checkpoints.

When you're done, the circuit should look something like <<lap-tracking-circuit>>.

img: lap-tracking-circuit

. Position the final checkpoint so that the finish line of the circuit is right in the middle of first and last checkpoints, which should be quite close together. See <<lap-tracking-circuit-end>>.

img: lap-tracking-circuit-end

. Position the vehicle slightly ahead of the lap start checkpoint.

. Create a canvas.

    . Create and add two game objects with a +Text+ component attached.
    . Make one display the text "Wrong Way!", and the other display "Lap 1".

. Create a new C# script called LapTracker, and add the following code to it.

// snip: lap_tracker
[source,csharp]
----
// Used to help figure out the start of the circuit with fewer lines of code.
using System.Linq;

public class LapTracker : MonoBehaviour {

    // The object that we're tracking as it makes laps around the circuit.
	[SerializeField] Transform target = null;

    // The number of nodes in the list we're permitted to skip. This prevents
    // the player from just driving a tiny circle from the start of the track
	// to the end ("I crossed the finish line three times! That means I win!")
    // Increase this number to permit longer shortcuts. Set this to zero to 
	// forbid any shortcuts.
	[SerializeField] int longestPermittedShortcut = 2;

    // The UI element that appears to let the player know they're going the wrong
    // way.
	[SerializeField] GameObject wrongWayIndicator;

    // A text field that displays the number of laps the player has completed.
	[SerializeField] UnityEngine.UI.Text lapCounter;

	// The number of laps the player has completed.
    int lapsComplete = 0;

    // The checkpoint that the player was near most recently.
	Checkpoint lastSeenCheckpoint;

    // The list of all checkpoints on the circuit. We keep a copy of it here, 
    // because we need to use this list every frame, and because using 
	// FindObjectsOfType to re-generate the list every frame would be slow.
    Checkpoint[] allCheckpoints;


	// The start checkpoint is the first (and hopefully only) checkpoint that
    // has isLapStart turned on.
	Checkpoint StartCheckpoint {
		get {
			// Get the checkpoint marked as the start of the lap
			return FindObjectsOfType<Checkpoint>()
                .Where(c => c.isLapStart)
                .FirstOrDefault();           
		}
	}

	void Start () {

        // Ensure that the counter says "lap 1"
		UpdateLapCounter();

		// The player isn't going the wrong way at the start
		wrongWayIndicator.SetActive(false);

		// Create the list of all checkpoints, which Update() will make use of
		allCheckpoints = FindObjectsOfType<Checkpoint>();

        // Create the circuit of connected checkpoints
		CreateCircuit();

        // Begin the race at the start of the circuit
		lastSeenCheckpoint = StartCheckpoint;
	}

	private void Update()
	{
		// What's the nearest checkpoint?
		var nearestCheckpoint = NearestCheckpoint();

        if (nearestCheckpoint == null) {
            // No checkpoints! Bail out.
            return;
        }

		if (nearestCheckpoint.index == lastSeenCheckpoint.index) {
			// nothing to do; the nearest checkpoint has not changed
		} else if (nearestCheckpoint.index > lastSeenCheckpoint.index) {

			var distance = nearestCheckpoint.index - lastSeenCheckpoint.index;

			if (distance > longestPermittedShortcut + 1) {
				// the player has skipped too many checkpoints. 
				// treat this as going the wrong way.
				wrongWayIndicator.SetActive(true);
			} else {
				// We are near the next checkpoint; the player is going the 
                // right way.
    			lastSeenCheckpoint = nearestCheckpoint;

				wrongWayIndicator.SetActive(false);
			}

		} else if (nearestCheckpoint.isLapStart && lastSeenCheckpoint.next.isLapStart) {
			// If the last checkpoint we saw is the last in the circuit, and our
			// nearest is now the start of the circuit, we just completed a lap!

			lastSeenCheckpoint = nearestCheckpoint;

			lapsComplete += 1;
			UpdateLapCounter();

		} else {
			// This checkpoint is lower than the last one we saw. The player
			// is going the wrong way.
			wrongWayIndicator.SetActive(true);
		}
	}

    // Calculates the nearest checkpoint to the player.
	Checkpoint NearestCheckpoint() {

        // If we don't have a list of checkpoints to use, exit immediately
		if (allCheckpoints == null) {
			return null;
		}

        // Loop through the list of all checkpoints, and find the nearest one
        // to the player's position.
		Checkpoint nearestSoFar = null;
		float nearestDistanceSoFar = float.PositiveInfinity;

		for (int c = 0; c < allCheckpoints.Length; c++) {
			var checkpoint = allCheckpoints[c];
			var distance = (target.position - checkpoint.transform.position)
				.sqrMagnitude;

			if (distance < nearestDistanceSoFar) {
				nearestSoFar = checkpoint;
				nearestDistanceSoFar = distance;
			}
		}

		return nearestSoFar;
	}


	// Walks the list of checkpoints, and makes sure that they all have
    // an index that's one higher than the previous one (except for the start
    // checkpoint)
	void CreateCircuit() {

        var index = 0;

        // Start at the start of the checkpoint
		var currentCheckpoint = StartCheckpoint;

		do
		{
			// We should not reach the end of the list - that means that the 
			// circuit does not form a loop
			if (currentCheckpoint == null)
			{
				Debug.LogErrorFormat("The circuit is not closed!");
				return;
			}

            // Update the index for this checkpoint
			currentCheckpoint.index = index;
			index += 1;

            // Move to the checkpoint it's pointing to
			currentCheckpoint = currentCheckpoint.next;

			// loop until we reach the start again
		} while (currentCheckpoint.isLapStart == false); 

	}

	// Update the text that's shown to the user
    void UpdateLapCounter()
    {
		lapCounter.text = string.Format("Lap {0}", lapsComplete + 1);
    }

    // Draw a line indicating the nearest checkpoint to the player in the scene
	// view. (Useful for debugging.)
	private void OnDrawGizmos()
	{
		var nearest = NearestCheckpoint();
		if (target != null && nearest != null) {

			Gizmos.color = Color.red;
			Gizmos.DrawLine(target.position, nearest.transform.position);

		}
	}
}
----

. Create a new empty game object, and add the +LapTracker+ component to it.

    . Set the +Target+ field to the vehicle.
    . Set the +Wrong Way Indicator+ field to the label that says "Wrong Way!"
    . Set the +Lap Counter+ field to the label that says "Lap 1".

. Play the game. When you drive the circuit in the right direction, the lap counter will go up when you cross the finish line. If you drive in the wrong direction, or take too much of a shortcut, the Wrong Way indicator will appear.

==== Discussion

