[[chapter_gameplay]]
== Gameplay

=== Introduction

Gameplay comes in many different guises.

=== Managing quests
// card: https://trello.com/c/QzEs0kfB

==== Problem

You want to manage a quest structure, where the player needs to complete certain objectives in order to finish a quest. 

As part of your quest structure, you want some objectives to be optional, and some objectives to not be presented to the player until they're achieved. If an objective is failed, and it isn't optional, then the entire quest is failed.

==== Solution

Before we can manage a quest structure, we need a quest. 

First, let's define a simple quest: we'll position the camera in front of some coloured blocks, and say that the player has to click on them in order to complete the quest. However, one of the blocks is forbidden, and clicking on it will fail the quest.

// image: quests1.png

First, we'll see need to create the scene for our quest:

. Create four cubes, and place them in front of the camera.

. For each of the cubes, create a Material, and add it by dragging and dropping it onto the cube in the Scene View.

. Change the colour of the material for each cube. Make one red, one green, one yellow, and one blue. (If any of these colours are hard to tell apart, change the colours to whatever suits you best.)

// image: quests2.png
// annotation: One of our cubes, showing how it is set up.

. Select the Main Camera, and add a Physics Raycaster to it.

Next, we'll create a canvas that displays the status of the quest and its objectives.

. Create a new canvas.
    . Add a game object with a Text component in it. 
    . Resize this object so that it can comfortably contain a paragraph of text.

Next, we'll set up the type of object that stores information about a quest.

. Create a new C# script called Quest, and add the following code to it:

// snip: quest

We can now create a quest.

. Open the Assets menu, and choose Create -> Quest.

. Name the new quest "Click on the Blocks".

. Click "Add Objective".
    . Name the new objective "Click on the red block".
    . Turn on the "Visible" checkbox.

. Repeat this process two more times - one each for the green and yellow blocks.
    . Make one of them optional, and one of them optional and not visible.

. Add one more objective, for the blue block.
    . For this one, set its name to "Don't click on the blue block".
    . Set its Initial Status to "Complete".

When you're done, the Inspector should look something like <<quests-objective-list>>.

img: quests-objective-list

We'll now set up the code that manages the quest.

Create a new C# script called QuestManager, and add the following code to it:

// snip: quest_manager

. Create a new empty game object, and add a +QuestManager+ component to it.
. Drag the Quest asset you created into its Starting Quest field.
. Drag the Text object that you set up earlier into its Objective Summary field.

Next, we'll set up a class that represents a change to an objective's status that can be applied when something happens.

. Create a new C# script called ObjectiveTrigger, and add the following code to it:

// snip: objective_trigger

Finally, we'll set up the cubes so that they complete or fail objectives when they're clicked.

. Create a new C# script called TriggerObjectiveOnClick, and add the following code to it:

// snip: trigger_objective_on_click

. Add a +TriggerObjectiveOnClick+ component to each of the cubes. For each one, drag in the Quest asset into its Quest field, and select the appropriate status that the objective should be set to (that is, set the blue cube to Failed, and the rest to Complete.)

<<quests-objective-trigger>> shows an example of one of the cube's +TriggerObjectiveOnClick+ after it's been configured.

img: quests-objective-trigger

. Play the game. The state of the quest is shown on the screen, and changes as you click on different cubes.

==== Discussion




=== Managing hitpoints
// card: https://trello.com/c/gt2ookt5

==== Problem

You want objects to take damage when another kind of object hits them. When they take enough damage, they're destroyed.

==== Solution

Create a script that can receive a signal that it has taken damage, and has an amount of 'hit points' that can be diminished.

. Create a new C# script called "DamageReceiver", and add the following code to it:

// snip: damage_receiver

Next, create a script that detects if it has collided with another; if that other object has a +DamageReceiver+ on it, it is told it has taken damage.

. Create a new C# script called "DamageGiver", and add the following code to it:

// snip: damage_giver

To test this, we'll create a script that creates and emits projectiles.

. Create a new C# script called "ProjectileShooter", and add the following code to it:

// snip: projectile_shooter

Finally, we'll set up some objects that demonstrate the system in action.

. Create a cube, name it "Damage Receiver", and attach the +DamageReceiver+ script to it.

. Create a sphere, and name it "Projectile".
    . Attach a Rigidbody to it. Disable gravity on the Rigidbody.
    . Attach a +DamageGiver+ component to it.
    . Drag the sphere from the Hierarchy into the Project tab. This will create a prefab.
    . Delete the original sphere from the scene.

. Create a cylinder, and name it "Shooter".
    . Attach a +ProjectileShooter+ script to it.
        . Drag the "Projectile" prefab into its Projectile Prefab field.
    . Position and orient the cylinder so that its forward direction - that is, its blue arrow - is aimed at the damage receiver.

. Start the game. The shooter will fire spheres at the target; after enough hit it, it will be removed from the scene.

==== Discussion


=== Creating a top-down camera
// card: https://trello.com/c/MJK2nm9w

==== Problem

You want to create a camera system that looks down at the world. You want to be able to move the camera around, and you want to limit the range that it can move around in.

==== Solution

Top-down cameras usually look best when they're looking down at an angle, not when they're aiming straight down the Y axis. However, we want the camera to move around only on the X and Z directions, parallel to the ground. 

. Create an empty game object, and call it Camera Rig.
. Move the Main Camera into the Camera Rig.
. Set the local position of the Main Camera to (0,0,0), so that it's at the same location as the Camera Rig.
. Rotate the camera (not the camera rig!) around the X axis so that it's looking down at the world.

Next, we'll add the code that moves the camera.

. Create a new C# script called TopDownCamera.cs, and add the following code to it:

// snip: top_down_camera

. Attach a TopDownCamera script to the Camera Rig.
. A red rectangle will appear on the same level as the camera (see <<top-down-camera-positioning>>). Adjust the minimum and maximum points in the Inspector so that they cover the area that you want the camera to move around in.

img: top-down-camera-positioning

. Play the game. The camera will move when you press the arrow keys, and won't leave the red rectangle. If the camera is outside the rectangle before the game starts, it will move inside it.

==== Discussion

=== Dragging a box to select objects
// card: https://trello.com/c/9T9fgHyS

==== Problem

You want to be able to click and drag the mouse to create a visible rectangle on screen. When you release the mouse, you want to know which objects were inside that rectangle.

==== Solution

First, we'll create the canvas that draws the box, and the box object itself.

. Open the GameObject menu, and choose UI -> Canvas.
. Open the GameObject menu again, and choose UI -> Image.
. Name the new Image "Selection Box".

Next, we'll create a script that can be told about when it's selected. 

. Create a new C# script called BoxSelectable, and add the following code to it:

// snip: box_selectable

. Create some objects - it doesn't matter what they are, cubes will do - and place them somewhere that the camera can see them.
    . Add a +BoxSelectable+ script to each of them.

Next, we'll create the script that updates the position and size of the selection box, and reports on which objects were selected.

. Create a new C# script called BoxSelection, and add the following code to it:

// snip: box_selection

. Attach a +BoxSelection+ component to the main camera.
    . Drag the "Selection Box" onto the Selection Box field.

. Run the game. You can click and drag to create the box; when you release the mouse, all objects within the rectangle that have a +BoxSelectable+ component will log that they were selected.

==== Discussion

If you use a sliced sprite, your selection box can have borders.

Discuss viewport space here.

=== Creating a menu structure
// card: https://trello.com/c/f9ChPe5k

==== Problem

You want to create a collection of menu pages, in which only one menu is visible at a time.

==== Solution

. Create a new script called +Menu+:

// snip: menu

. Create a new script called +MenuManager+:

// snip: menu_manager

Next, we'll create a sample menu. It'll have two screens: a main menu, and an options menu.

. Create a new game object, and call it Menu Manager. Add a +MenuManager+ script to it.

. Create a canvas.

. Create a new child game object called "Main Menu". This will act as a container for the menu's controls.

    . Add a Menu script to this object.
    . Add a button game object to the Main Menu. Name this button "Show Options Menu Button". 
    . Set its Text to say "Options Menu". 

. Duplicate the "Main Menu" object, and rename it to "Options Menu".

    . Rename its "Show Options Menu Button" to "Show Main Menu Button".
    . Change its text to say "Back". 

. Select the Menu Manager
. Drag the Main Menu onto the Menus slot.
. Drag the Options Menu onto the Menus slot.

Next, we'll make the buttons show the appropriate menus.

. Select the "Show Options Menu Button" inside the Main Menu.

    . Add a new entry in the button's On Click event.
    . Drag the Menu Manager into the object field.
    . In the Function drop-down menu, choose MenuManager -> ShowMenu.
    . Drag the Options Menu object into the parameter field.
    . When you're done, the On Click event should look like <<menu-manager-show-options-onclick>>.

img: menu-manager-show-options-onclick

. Select the "Show Main Menu Button" inside the Options Menu.

    . Add a new entry in the button's On Click event.
    . Drag the Menu Manager into the object field.
    . In the Function drop-down menu, choose MenuManager -> ShowMenu.
    . Drag the Main Menu object into the parameter field.
    . When you're done, the On Click event should look like <<menu-manager-show-main-onclick>>.

img: menu-manager-show-options-onclick

. Run the game. The main menu will appear; clicking the options button will hide it and show the options menu, and clicking the Back button will return you to the main menu.

==== Discussion

Discuss how you can add other function calls to each +Menu+; <<menu-manager-menu-events>>

img: menu-manager-menu-events


=== Creating a wheeled vehicle
// card: https://trello.com/c/CBS1ZmaA

==== Problem 

You want to implement a vehicle with wheels, like a car.

==== Solution 

. Create an empty object called "Vehicle".
. Add a Rigid Body to it.

    . Set its Mass to 750.
    . Set its Drag to 0.1.

. If you have a car mesh to use, add it as a child of the Vehicle object
    . If you don't have a mesh, add a cube as a child and scale it so that it's the right shape and size of a car. If you do this, make sure you remove the Box collider that comes with the cube.
    . In either case, make sure that your visible object's position is (0,0,0), so that it's in the right 

. Create an empty game object as a child, call it "Colliders"

    . Add an empty game object to "Colliders"; name it "Body".
    . Add a Box Collider to the "Body" object.
    . Click Edit Collider, and click and drag the box so that it fits closely around the visible car object.

. Create a new empty child object of "Colliders", and name it "Wheel Front Left".

    . Add a Wheel Collier to this new object.
    . Position this near where you want the front-left tire to be. If you're using a car mesh, place it in the middle of the visible tire.
    . Adjust the Radius of the wheel to the size you want. (It's okay if the wheel collider goes inside the Body collider.)

. Duplicate the wheel three times - one for each of the other three tires. Move each to one of the other tires, and rename them appropriately. When you're done, the colliders should look something like <<vehicle-wheel-placement>>

img: vehicle-wheel-placement

. Create a new script, and call it Vehicle. Add the following code to it:

// snip: vehicle

. Select the "Vehicle" object, and add 4 entries to the Wheels list.
. For each of the entries:
    . Add one of the wheel colliders.
    . If it's a rear wheel, turn on Powered.
    . If it's a front wheel, turn on Steerable.
    . Turn on Has Brakes.

. Play the game. You should be able to drive the car around.

==== Discussion 

Consider adding an orbiting camera to follow the vehicle as it moves.

Consider what happens when all of the wheels are steerable, or all of them are powered.

Modify the mass of the vehicle, or the torque values.

Wheel colliders define their own suspension paramters. Play with them.


=== Keeping a car from tipping over
// card: https://trello.com/c/cPcw2cbK

==== Problem

You want your car to not flip over when doing sharp turns.

==== Solution

Your car tips over because it's rotating around its center of mass, which is too high up. When the center of mass is lower, any rotation around it will force the wheels into the ground harder, instead of flipping the entire car over.

. Create a new C# script called +AdjustCenterOfMass+, with the following code:

// snip: adjust_center_of_mass

. Add this component to the game object containing your vehicle's rigid body.

. Move the Center of Mass's Y coordinate down a bit, so that it's just at the floor of the vehicle. The lower the center of mass, the more stable the vehicle will be.

==== Discussion

Discuss how rigidbodies usually compute their center of mass from their colliders, but you can override it

Discuss how it's less realistic but makes for better gameplay

(in real life a car's center of mass is low beacuse of heavy objects like the transmission and engine being under the floor)


=== Creating speed boosts
// card: https://trello.com/c/Z744jhZo

==== Problem

You want to create objects on your race track that give a temporary speed boost to vehicles that drive over them.

==== Solution

First, create the visible component of the speed boost. In this example, we'll go for a simple, cartoonish look.

. Create a new Material, and call it Speed Boost.
    . Set its Albedo colour to red.

. Open the GameObject menu, and choose 3D Object -> Plane. 
    . Position and scale the object appropriately on your track. 
    . Name the object "Speed Boost".
    . Drag the Speed Boost material onto it.
    . Remove the Mesh Collider from the object.
    . Add a Box Collider.
        . Turn on Is Trigger.
        . Adjust the size and position so that it creates a volume big enough for a car (for example, <<racing-speed-boost>>)

img: racing-speed-boost


. Create a new C# script called SpeedBoost, and add the following code to it:

// snip: speed_boost

. Attach a +SpeedBoost+ component to the speed boost object.

. Test the game. When a vehicle enters the boost area, it will be boosted forward for a short duration.

==== Discussion


=== Creating a camera that orbits around its target
// card: https://trello.com/c/3PrteZ6M

==== Problem

You want to create a camera that rotates around a target's position at a fixed distance (sometimes referred to as a "chase camera".)

==== Solution

. Add a camera to the scene

. Create a new C# script called +OrbitingCamera+

. Replace its code with the following:

// snip: orbiting_camera

. Add a cube to the scene.
. Select the camera, and drag the cube's entry in the hierarchy into the +target+ field.
. Run the game. As you move the mouse, the camera will rotate around the target.

==== Discussion

=== Creating orbiting cameras that won't clip through walls
// card: https://trello.com/c/RCcebmcr

==== Problem

You want to detect when there's an object between the camera and the target, and move the camera closer.

==== Solution

Add the following variable to the orbiting camera class:

// snip: orbiting_camera_clip_variables

Next, add the following code to the class' +LateUpdate+ method:

// snip: orbiting_camera_clip_code context:5

Turn on Clip Camera on your Orbiting Camera. The camera will now move closer to the target if there's a collider between the camera and the target.

==== Discussion

Raycasts will only hit colliders, if there's an object that blocks the camera but doesn't have a collider attached, the script won't know to move closer.

=== Detecting when the player has completed a lap
// card: https://trello.com/c/o7kSGKJc

==== Problem

You want to detect when the player has completed a lap around a race circuit. You also want to detect if the player is going the wrong way, or if the player is cheating by taking too much of a shortcut.

==== Solution

You can solve this by creating a set of checkpoints that the player must pass, in order. If the player is passing checkpoints in the wrong order, they're going the wrong way.

. Start by laying out your track, so that both you and the player will know the path they need to take. See <<lap-tracking-track>>.

img: lap-tracking-track

. Add a vehicle to the scene, and ensure that you're able to drive around (just to make sure that the driving component works.)

. Create a new C# script called Checkpoint, and add the following code to it. Note that it contains two classes - one of them is special editor-only code that adds buttons to the Inspector to help build the track.

// snip: checkpoint

. Create a new empty game object called "Checkpoints".

. Add a new empty game object as a child of Checkpoints. Name it "Checkpoint", and add a Checkpoint component to it.
. Position this checkpoint at the start of the racetrack.
. Turn on Is Lap Start.
. Click Insert Checkpoint in the Inspector. A new checkpoint will be added and selected. Position it further along the track.
. Continue inserting new checkpoints. You can also select an earlier checkpoint and click Insert Checkpoint to insert a new checkpoint between two existing points, or delete a checkpoint by selecting the previous checkpoint and clicking Delete Next Checkpoint.
. When you've completed the circuit, select the last checkpoint and drag the lap start checkpoint (the one with a yellow marker) into its Next field.


NOTE: If the connections between checkpoints get messed up, you can fix it by changing the Next field on checkpoints.

When you're done, the circuit should look something like <<lap-tracking-circuit>>.

img: lap-tracking-circuit

. Position the final checkpoint so that the finish line of the circuit is right in the middle of first and last checkpoints, which should be quite close together. See <<lap-tracking-circuit-end>>.

img: lap-tracking-circuit-end

. Position the vehicle slightly ahead of the lap start checkpoint.

. Create a canvas.

    . Create and add two game objects with a +Text+ component attached.
    . Make one display the text "Wrong Way!", and the other display "Lap 1".

. Create a new C# script called LapTracker, and add the following code to it.

// snip: lap_tracker

. Create a new empty game object, and add the +LapTracker+ component to it.

    . Set the +Target+ field to the vehicle.
    . Set the +Wrong Way Indicator+ field to the label that says "Wrong Way!"
    . Set the +Lap Counter+ field to the label that says "Lap 1".

. Play the game. When you drive the circuit in the right direction, the lap counter will go up when you cross the finish line. If you drive in the wrong direction, or take too much of a shortcut, the Wrong Way indicator will appear.

==== Discussion

