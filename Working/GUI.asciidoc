== GUIs

=== Working with UI controls
// card: https://trello.com/c/C6aVwKBn

===== Problem

You want to build a user interface for the player to work with.

===== Solution

. Open the GameObject menu, and choose UI -> Canvas.
. Open the GameObject menu again, and choose UI -> Text. A Text object will be added to the Canvas.
. Select the Rectangle tool, and drag the Text to resize and re-position it.
. Select the Text object, and modify the Text's properties to change its text.


. Create a new C# script called ButtonClicked.cs, and add the following code to it:

// snip: button_clicked
[source,swift]
----
// Snippet: 0-button_clicked.txt

public class ButtonClicked : MonoBehaviour {

    // This will appear in the list of methods
    public void ButtonWasClicked() {
        Debug.Log("The button was clicked!");
    }

    // This will appear in the list of methods, and let you specify a parameter
    public void ButtonWasClickedWithParameter(string parameter) {
        string message = 
            string.Format("The button was clicked: {0}", parameter);

        Debug.Log(message);
    }

    // This won't appear in the list of methods, because it's private
    // (even though we didn't specify its protection level, because all class
    // methods are private by default in C#)
    void PrivateButtonWasClicked() {
        Debug.Log("This won't run as the direct result of a button click!");
    }

}
----

. Attach a +ButtonClicked+ component to the Canvas, or to any other game object - for the purposes of this example, it doesn't matter which.

. Open the GameObject menu one more time, and choose UI -> Button.
. Select the Button, and click the `+` button under the button's On Click component.
. Drag the object you attached the +ButtonClicked+ component to, into the new object field that appears.

    . In the function drop-down that now appears, choose ButtonClicked->ButtonWasClicked.

. Run the game. When you click the button, text will appear in the console.

. Stop the game, and click the `+` button again. Drag the same object in, and choose ButtonClicked->ButtonWasClickedWithParameter. Note how this method lets you specify a string to send when the button was clicked.

. Note also that the PrivateButtonWasClicked method never appears in the list of methods you can choose.

===== Discussion


Discuss how objects on the canvas have a Rect Transform, which defines their position as a rectangle within the context of the canvas.

Discuss how anchors work, and how they control how positioning and sizing work.

Discuss how the different anchor presets work.

Discuss the canvas modes (overlay, camera, world-space), and their differences.

Discuss the canvas scaler, its different modes, and what they're useful for.

Discuss how unity events work (the On Click handler on the button etc), including visibility, parameters, and how they work with properties.

=== Theming controls
// card: https://trello.com/c/OOrMFakO

===== Problem

You want to use your own artwork for your controls, rather the built-in Unity artwork. You want that art to be able to scale as the controls change size, without stretching.

===== Solution

. Start by importing the textures you want to use.
    . Ensure that the textures are configured to be imported as "Sprite / UI".

For this example, we'll customise a panel, using art from the open source UI asset kit by Kenney, available at http://kenney.nl/assets/ui-pack.

. Open the GameObject menu, and choose UI -> Panel.
    . Select the Panel game object, and change its Source Image to the +blue_panel+ image.

. Resize the panel, and you'll see that the image stretches (<<panel-stretch>>)

img: panel-stretch

To fix this, we need to set up the sprite so that only certain regions get stretched. In this texture, everything except the corners can be scaled without looking bad, so we'll set it up accordingly.

. Select the blue_panel texture.
. Click the Sprite Editor button.
. The Sprite Editor will appear. Drag the green dot that appears at the top of the screen down, until the green line is underneath the rounded corners of the image. You can also manually type in the change, by setting the border's +T+ value to 5.
. Repeat this process for the other three edges. When you're done, the sprite editor window should look like <<sprite-editor>>.

img: sprite-editor

. Click Apply, and close the Sprite Editor.
. Select the Panel object.
. Change the Image component's Image Type from Simple to Sliced.
. The stretched appearance will go away, because only the middle areas of the sprite are allowed to stretch, and the shape of the corners will be preserved (<<panel-stretch-fixed>>)

img: panel-stretch-fixed

===== Discussion



=== Animating the UI
// card: https://trello.com/c/4wzH30ML

===== Problem

You want to animate parts of the user interface.

===== Solution

We'll make a button spin when it's clicked.

. Open the GameObject menu, and choose UI -> Button.

. Create a new C# script called SpinButton.cs, and add the following code to it:

// snip: spin_button
[source,swift]
----
// Snippet: 1-spin_button.txt

public class SpinButton : MonoBehaviour {

    // The amount of time needed to perform a full spin
    [SerializeField] float spinTime = 0.5f;

    // Controls the pacing of the animation.
    [SerializeField] AnimationCurve curve = AnimationCurve.EaseInOut(0, 0, 1, 1);

    public void Spin() {

        // Start a spin.
        StartCoroutine(StartSpinning());

    }

    // A coroutine that updates the rotation every frame, until it runs out of
    // time.
    private IEnumerator StartSpinning()
    {
        // Don't do any spinning if spin time is zero or less (
        if (spinTime <= 0) {
            yield break;
        }

        // Keep track of how long we've been spinning for.
        float elapsed = 0f;

        while (elapsed < spinTime) {
            elapsed += Time.deltaTime;

            // Calculate how far along the animation we are, measured between 
            // 0 and 1.
            var t = elapsed / spinTime;

            // Use this value to figure out how many degrees we should be 
            // rotated at on this frame.
            var angle = curve.Evaluate(t) * 360f;

            // Calculate the rotation by rotating this many angles around
            // the X axis.
            transform.localRotation = Quaternion.AngleAxis(angle, Vector3.right);

            // Wait a new frame.
            yield return null;
        }

        // The animation is now complete. Reset the rotation to normal.
        transform.localRotation = Quaternion.identity;
    }
}
----

. Attach a +SpinButton+ component to it.

. Click the `+` button in the On Click field.
    . Drag the button itself into the field.
    . In the popup menu, choose SpinButton->Spin.

. Run the game. When you click the button, it will spin around.

You can also adjust the curve to control the pacing of the animation, as well as its duration.

===== Discussion

Discuss animation curves. Discuss what 'evaluating' the curve means. Discuss the benefits of doing it this way, instead of incrementing the rotation every frame.

Discuss how objects in the canvas can be positioned and rotated just like other objects

Discuss how you can also animate their properties just like other objects.


=== Creating a list of items
// card: https://trello.com/c/K9ijXDmM

===== Problem

You want to create a scrolling list of UI items.

===== Solution

First, we'll create the container for the list.

. Create a scroll view by opening the GameObject menu and choosing UI->Scroll View.
. Select the Content object in the Scroll View. 
    . Add a Vertical Layout Group to it. 
        . Turn on the Width checkbox in Child Controls Size. This will make the objects inside the Content object expand their width to fill their parent, while still having control over their own height.
    . Add a Content Size Fitter component to it.
        . Set the Vertical Fit setting to Preferred Size. This will make the Content object adjust its height to be the total height of its children.

Next, we'll create our prototype list object.

. Create a Panel. Name it "List Item".
    . Drag the List Item onto the Content object in the Scroll View. It will resize to the width of the Content.
. Create a new Text object by opening the GameObject menu and choosing UI->Text.
    . Make it a child of the List Item.
    . Set its minimum anchor to (0,0), and its maximum anchor to (1,1). This will make it define its size relative to the width and height of its parent.
    . Set its Left, Top, Bottom and Right to 5. This will inset the Text by 5 pixels on all edges.

Next, we'll add some code that lets each list item manage its content.

. Create a new C# script called ListItem.cs. Add the following code to it:

// snip: list_item
[source,swift]
----
// Snippet: 2-list_item.txt

public class ListItem : MonoBehaviour {

    // The Text object that displays our label
    [SerializeField] UnityEngine.UI.Text labelText;

    // Expose a string; setting or getting this will set or get the text of
    // the label.
	public string Label
    {
        get
        {
            return labelText.text;
        }
        set
        {
            labelText.text = value;
        }
    }

}
----

. Add a ListItem script to the List Item.
    . Drag the Text into the Label Text field.

. Drag the List Item object from the hierarchy into the Project tab. This will create a prefab.
. Delete the List Item from the scene.

Finally, we'll add code that populates the list with instances of the List Item.

. Create a new C# script called List.cs. Add the following code to it:

// snip: list
[source,swift]
----
// Snippet: 3-list.txt

public class List : MonoBehaviour {

    // The number of items to create
    [SerializeField] int itemCount = 5;

    // Each list item will be of this type
    [SerializeField] ListItem itemPrefab;

    // The object that new items should be inserted into
    [SerializeField] RectTransform itemContainer;

	void Start () {

        // Create as many items as we need to
        for (int i = 0; i < itemCount; i++)
        {
            var label = string.Format("Item {0}", i);

            // Create a new item
            CreateNewListItem(label);

        }

    }

    public void CreateNewListItem(string label)
    {
        var newItem = Instantiate(itemPrefab);

        // Place it in the container; tell it to not keep its current
        // position or scale, so it will be laid out correctly by the UI
        // system
        newItem.transform.SetParent(itemContainer, worldPositionStays: false);

        // Give it a label
        newItem.Label = label;
    }

}
----

. Add a List component to the scroll view. 
    . Drag the List Item prefab into its List Item Prefab slot.
    . Drag the Content object into its List Container slot.

. Run the game. The list will now contain a scrollable collection of items.

===== Discussion

Discuss what scroll views do, how they work, what they're composed of (content area, clip area, scroll views)

Discuss how layout groups work.



=== Fading out a list
// card: https://trello.com/c/ta4DtcYY

===== Problem

You want to manage a list of items that fade out some time after being removed.

===== Solution

. Start with the List example from the previous recipe.
. Duplicate the List Item prefab, and name the new prefab "Fading List Item".
. Select the Fading List Item prefab, and add a Canvas Group component. This will allow you to fade the entire object.

. Configure the List object to use the new Fading List Item.

. Add a new Button to the scene. 
    . Set its Text to read "Add Item".
    . Add a new entry in its On Click list. 
    . Drag the List object into its object field, and select the List -> CreateNewListItem method. 
    . Type "New List Item" into the text field.

. Create a new C# Script called FadeAfterDelay.cs, with the following code:

// snip: fade_after_delay
[source,swift]
----
// Snippet: 4-fade_after_delay.txt

public class FadeAfterDelay : MonoBehaviour {

    // The number of seconds before a fade starts
    [SerializeField] float delayBeforeFading = 2f;

    // The amount of time to take while fading out
    [SerializeField] float fadeTime = 0.25f;

    // Notice the return type - this Start method is a coroutine!
    IEnumerator Start () {

        // Wait the required amount of time
        yield return new WaitForSeconds(delayBeforeFading);

        // We need a canvas group in order to fade
        CanvasGroup canvasGroup = GetComponent<CanvasGroup>();

        if (canvasGroup == null) {
            Debug.LogWarning("Cannot fade - no canvas group attached!");
            yield break;
        }

        // Fade time must be more than zero in order for a fade to be 
        // animated
        if (fadeTime <= 0) {
            yield break;
        }

        // Keep track of how much time we've spent fading
        var fadeTimeElapsed = 0f;

        // Perform the fade every frame
        while (fadeTimeElapsed < fadeTime) {

            fadeTimeElapsed += Time.deltaTime;

            // Calculate the fraction of the fade time (between 0 and 1)
            var t = fadeTimeElapsed / fadeTime;

            // Calculate our alpha; it starts at 1, and goes to 0
            var alpha = 1f - t;

            // Apply the fade
            canvasGroup.alpha = alpha;

            // Wait for the next frame
            yield return null;
        }

        // Remove this game object from the scene
        Destroy(gameObject);
	}


}
----

. Attach a +FadeAfterDelay+ component to the Fading List Item.

. Run the program. When you click the button, a new list item will appear; after a moment, it will fade out.


===== Discussion




=== Creating on-screen position indicators
// card: https://trello.com/c/TL3qYhNS

===== Problem


You want to display icons that highlight the position of objects on screen.

===== Solution

// TODO

===== Discussion


=== Custom editors
// card: https://trello.com/c/MeMTnS06

===== Problem

You want to customise the Inspector for a component.

===== Solution

We'll create a script that, when paired with a custom editor, allows you to quickly build a brick wall. When you add a Wall component, you'll specify the width and height of the wall, as well as a prefab to use for the brick. A button will in the inspector; when you click it, it will create bricks as child objects.

First, we'll create the brick prefab.

. Create a new Cube. Name it "Brick".
. Set its scale to (2, 1, 1).
. Drag it from the Hierarchy tab into the Project tab. This will create a new prefab.
. Delete the original Brick from the scene.

Next, we'll write the code for the wall. This file will contain two classes: one for the Wall component, and one for the custom editor.

. Create a new C# script called Wall.cs. Add the following code to it:

// snip: wall
[source,swift]
----
// Snippet: 5-wall.txt

#if UNITY_EDITOR
// Bring in the UnityEditor namespace, if this file is being compiled for
// the editor. (Code between the #if and #endif won't be included in the final 
// game; it will only be available in the editor.)
using UnityEditor;
#endif

// A wall.
public class Wall : MonoBehaviour
{
    [SerializeField] public int rows = 5;
    [SerializeField] public int columns = 5;

    [SerializeField] public Renderer brickPrefab;
}


#if UNITY_EDITOR
// The Editor object that will manage the Inspector for Wall components.
[CustomEditor(typeof(Wall))]
public class WallEditor : Editor {

    // Called by Unity to display the contents of the Inspector for this object.
    public override void OnInspectorGUI()
    {
        // Make sure that we have the latest data stored in the 
        serializedObject.Update();

        EditorGUILayout.PropertyField(serializedObject.FindProperty("rows"));
        EditorGUILayout.PropertyField(serializedObject.FindProperty("columns"));

        EditorGUILayout.PropertyField(serializedObject.FindProperty("brickPrefab"));

        serializedObject.ApplyModifiedProperties();

        if (GUILayout.Button("Create Wall")) {
            CreateWall();
        }
    }

    void CreateWall() {
        // Register the state of this object before we make changes to its contents
        Undo.RegisterFullObjectHierarchyUndo(target, "Create Wall");

        var wall = target as Wall;

        if (wall == null) {
            return;
        }

        // Temporarily store all current children
        GameObject[] allChildren = new GameObject[wall.transform.childCount];

        int i = 0;

        // We can't call DestroyImmediate on the objects in a list that we're 
        // iterating over, because doing that would change the size of the list
        // as we're iterating over it. Instead, we copy references to them into 
        // an array of fixed size, and then destroy that.

        // Find all child objects, and temporarily put them in the array
        foreach (Transform child in wall.transform)
        {
            allChildren[i] = child.gameObject;
            i += 1;
        }

        // We can now iterate over that array and destroy them
        foreach (GameObject child in allChildren)
        {
            // Destroy the object, and also record it as an undo-able action
            DestroyImmediate(child.gameObject);
        }

        // We can now replace them with new objects
        var brickSize = wall.brickPrefab.GetComponent<Renderer>().bounds.size;

        for (int row = 0; row < wall.rows; row++) {

            // Figure out where the row should be
            var rowPosition = Vector3.zero;
            rowPosition.y += brickSize.y * row;

            for (int column = 0; column < wall.columns; column++)
            {
                // Figure out where the brick should be
                var columnPosition = rowPosition;
                columnPosition.x += brickSize.x * column;

                // Every second row is offset a bit
                if (row % 2 == 0) {
                    columnPosition.x += brickSize.x / 2f;
                }

                // PrefabUtility.InstantiatePrefab is like Instantiate, but it
                // remembers that it was a prefab, and maintains the connection.
                // (We have to cast it to GameObject because there's no generic
                // version of InstantiatePrefab - the compiler won't figure 
                // out the type automatically based on the type that was 
                // passed in.

                var brick = PrefabUtility
                    .InstantiatePrefab(wall.brickPrefab.gameObject) as GameObject;

                // Give it a name appropriate to its position
                brick.name = string.Format("{0} ({1},{2})",
                                           wall.brickPrefab.name, column, row);

                // Place it in the scene
                brick.transform.SetParent(wall.transform, false);

                // Update its position, relative to its parent
                brick.transform.localPosition = columnPosition;

                // Don't rotate it, relative to its parent
                brick.transform.localRotation = Quaternion.identity;

            }
        }
    }

}
#endif 
----

. Create a new empty game object, called "Wall". Add a +Wall+ component to it.

. Drag the Brick prefab into the Brick Prefab slot.

. Click the Create Wall button. A wall of bricks will appear.

===== Discussion

Discuss how editors draw their contents.
Discuss GUILayout.
Discuss EditorGUILayout.
Discuss PropertyField.
Discuss GUILayout.Button, as well as some other methods in GUILayout and EditorGUILayout that produce fields.
Discuss how PrefabUtility.InstantiatePrefab differs from Instantiate (it maintains the prefab connection, Instantiate doesn't)

=== Attribute drawers
// card: https://trello.com/c/iSoIDoTN

===== Problem

You want to customise how the Inspector draws a type of variable when a certain attribute is attached to it. For example, the +Header+ attribute causes Unity to draw a label above a variable in the Inspector.


===== Solution

helpbox attribute

===== Discussion



=== Scripted importers
// card: https://trello.com/c/nhi9erP9

===== Problem

You want to write code that lets Unity import a new type of files.

===== Solution


===== Discussion



=== Property drawers
// card: https://trello.com/c/GyeyJX18

===== Problem

You want to customise how the Inspector draws variables of a certain type. For example, you've got a custom class, and you want to customise how it appears.

===== Solution


===== Discussion

Discuss how normally Unity draws the child properties of a class

Discuss how you need to do all of it yourself if you override it

=== Asset post processing
// card: https://trello.com/c/44Ubj2DP

===== Problem

You want to customise how Unity imports certain files. 

===== Solution


===== Discussion



=== Wizards
// card: https://trello.com/c/FI6nVBmY

===== Problem

You want to create and display a window in the Unity Editor that lets the user provide some values, and runs code when the user clicks a button.

===== Solution


===== Discussion

