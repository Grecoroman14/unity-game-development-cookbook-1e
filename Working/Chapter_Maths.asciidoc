[[chapter_maths]]
== Maths

=== Introduction

Maths is an unavoidable part of video game development. Like it or loath it, you need to use it, acknowledge it, and even downright embrace it to get anything done. This chapter explores some of the most common maths-related problems you'll encounter when developing games using Unity. 

[NOTE]
====
This isn't all the maths you'll need for game development: far from it! But it's enough maths to help out, and we've done our best to structure it around the problems you might want to solve using the maths, rather than the maths itself.
====

Ever wondered what a vector is? Or how to use a matrix? What about a quaternion?  We'll cover them here, while also touching on common maths problems in game development, like calculating the angles and distances to something else in your Unity-based game.

Read on for just enough Math development.

[TIP]
====
We can't recommend Paco Nathan's _Just Enough Math_ video series, also from O'Reilly Media, more highly. Check it out if you want to learn even more maths: http://shop.oreilly.com/product/110000527.do
====

=== Storing coordinates of varying dimensions using Vectors
// card: https://trello.com/c/K8vCgHZD

==== Problem

Game development involves a lot of coordinates, of varying dimensions:

* one-dimensional coordinates, such as `1` or `-9`
* two-dimensional coordinates, such as `8,3` or `-1,4`
* three-dimensional coordinates, such as `3,1,-3` or `-7,6,1`

Realistically, when you're building a game, as long as you're keeping track of what you need to keep track of, it often doesn't matter how you do it. However, one common, useful way of keeping track of coordinates is vectors.

Vectors a set of coordinates, of varying dimensions. Thus, our problem here is: how do I use vectors and Unity, and what can I use them for?

[TIP]
====
We often assign a specific meaning to vectors: in video games it's usually coordinates in geometry, but there's absolutely no reason you can't store anything you want in them. They're just a data structure.
====

==== Solution

To to provide a solution here we're going to have to unpack the problem a little. We admit, we wrote a deliberately broad problem statement, but that's so we can show you everything you need to know about vectors without having to have one tiny recipe for each manipulation or action you might want to make with a vector.

First up, in Unity, you can define a Vector2: one with two components, typically an x and a y. A Vector2 is typically used to represent a point in 2D space in a Unity game.

You can define a Vector2 with two dimensions: 

// snip: vector2

Or use one of Unity's built-in vectors:
// snip: vector2builtin

[TIP]
====
You can learn more about Vector2 and 3in Unity's API documentation at  https://docs.unity3d.com/ScriptReference/Vector2.html and https://docs.unity3d.com/ScriptReference/Vector3.html
====

Unity also has a Vector3, a vector with three dimensions, which can be defined as follows:

// snip: vector3

Every Transform component in Unity has local direction vectors defined, which are relative to their current rotation, for example forward could be accessed as:

// snip: local_directions

Naturally, you can perform basic arithmetic with vectors. Vectors can be added together:

// snip: vector_add_subtract

And vectors can be subtracted from each other:
// snip: vector_subtract

[NOTE]
====
The magnitude of a vector is its length. It's calculated by taking the square root of the sum of the squares of its components. A vector whose magnitude is 1 is called a "unit" vector.
====

You can also get the magnitude of a vector:

// snip: vector_magnitude

The magnitude can then be used to make other calculations, such as the distance between two vectors:

// snip: vector_distance

There's also a built in method, `Distance`:

// snip: vector_distance2

Calculating the magnitude of a vector requires a square root. However, if you just care about finding out if one distance is bigger than another, you can skip the square root. and work with the square of the magnitude. 

Doing this is a bit faster, and we care quite a lot about fast calculations in game development. To get this, use the `sqrMagnitude` property:

// snip: vector_magnitude2

Lots of operations work best on vectors that have a magnitude of 1. A vector with magnitude of 1 is also called a "unit" vector, because its magnitude is a single unit (that is, one.) You can take a vector and produce a new one that has the same direction but with magnitude of 1 by dividing it by its own magnitude This is called "normalizing" it:

// snip: vector_normalise

This is a common operation, so you can directly access a normalized version of a vector by using the 'normalized' property:

// snip: vector_normalise2

Vectors can also be scaled, either by a single regular number (a scalar), like so:

// snip: vector_scaling

Or by using the scale method and passing in another vector:

// snip: vector_scaling2

You can also get the dot product of two vectors, which tells you the difference between the directions they are pointing. The dot product between two vectors aiming in the same direction is 1:

// snip: dot_product

The dot product between two vectors aiming in the opposite directions is -1:

// snip: dot_product2

The dot product between two vectors at right-angles to each other is 0:

// snip: dot_product3

The dot product is also the arc cosine of the angle between the two vectors (`Mathf.Acos works in radians):

// snip: dot_product4

The dot product is a great way to tell if an object is in front of, or behind, another:

// snip: dot_product5

The cross product, a third vector orthogonal to (at right angles to) two input vectors, is also available:

// snip: cross_product

[TIP]
====
The cross product is only defined for three-dimensional vectors. 
====

You can also get a new vector from two vectors, moving from one to the other at a certain magnitude. This is particularly useful to prevent overshooting. Here we move from `(0,0,0)` to `(1,1,1)`, without moving any futther than 0.5 units:

// snip: move_towards

Or reflect off a plane, defined by a normal:

// snip: vector_reflect

Or lerp (linearly interpolate) between two input vectors, given a number between 0 and 1. If you provide 0, you'll get the first vector, if you provide 1 you'll get the second, and if you provide 0.5, you'll get somewhere right in the middle of the two:

// snip: vector_lerp

If you specify a number outside of the range of 0 to 1, lerp will clamp it to 0 to 1. You can prevent this by using `LerpUnclamped`:

// snip: vector_lerp2

...that's just some of the things that you can do with vectors in Unity! But what are these useful for? Read on, for the discussion, to find out.

===== Discussion

////
* Vector2
* Vector3
* Common vectors (up, down, left, right, back, forward)
* Vector magnitude and what it is
* Vector addition and subtraction
* Measuring the distance between two points
* Quickly comparing the distance between two points using sqrMagnitude
* Scaling vectors
* Dot product and what it's useful for (measures the difference between the direction that two vectors point in)
* Cross product and what it's useful for (produces a vector that's orthogonal to both the inputs)
* Vector projection and what it's useful for
* MoveTowards is useful for making a vector move over time without overshooting
* Reflect is useful for bouncing a vector off a plane defined by a normal
* Lerp lets you interpolate between two vectors
* LerpUnclamped does the same, but doesn't clamp
////

That's just a taste of the basics of using vectors in Unity. But, as we said earlier, you never actually have to use vectors: if you have another way of keeping track of coordinates of a certain dimension, and it's working for you, then feel free to use that. You'll probably find Unity's inbuilt support for vectors, and the convenience functions and types provided, quite convenient though!

The mathematical operations that you can perform on a vector, provided by Unity, make a lot of things straightforward. The dot product, for example, can be used to tell if a point is in front of a player character, or behind them, or create a radar, to figure out where enemies are.

Vectors also make complex operations, like scaling, or rotating something, very straightforward. Instead of having to calculate each object and their relation to each other manually, you can just use vector math. 

Basically, vectors let you address geometry-related issues with significantly cleaner code than you would otherwise need. They're wonderful mathematical tools in your game development toolkit!

=== Rotating in 3D space
// card: https://trello.com/c/pQXNT5Rv

==== Problem

You want to rotate things in 3D space. 

==== Solution

To rotate in 3D space, you'll need to work with quaternions. Quaternions can be a tricky beast, inspiring fear in the eyes of game developers new and experienced alike. 

But really, all they are is a rotation, and for most game development purposes it doesn't matter if you don't quite understand exactly what a quaternion is and how it works: it's just a rotation.

For example, you can use a quaternion to define a rotation that rotates around 90 degrees on the X axis:

// snip: quaternions1

And then use this to rotate a point around the origin:

// snip: quaternions2

There is an identity quaternion, which represents no rotation at all:

// snip: quaternions3_identity

And you can interpolate between two rotations using the `Slerp` method, which smoothly moves between rotations in a way that means the change in angle is constant at every step. This is better than a linear interpolation of angles, in which the angles change at a non-constant rate:

// snip: quaternions4

[TIP]
====
Slerp is short for spherical linear interpolation.
====

You can also combine quaternions together: for example to rotate something around the Y axis, and then around the X axis, you multiply them (they're applied in the reverse order):

// snip: quaternions5

[NOTE]
====
This combination is not commutative: the order of multiplication matters!
====

===== Discussion

You can do all sorts of exciting things with quaternions—rotations—including rotating a point around the origin and slerping (spherical linear interpolation) cleanly between different rotations: but what does it all mean for game development?

// TODO: what are Quaternions for?

=== Performing transformations in 3D space with Matrices
// card: https://trello.com/c/eWBNupad

==== Problem

You want to perform transformations in 3D space. 

==== Solution

Performing transformations on points and directions in 3D space means working with matrices. A matrix is just a grid of numbers:

// snip: matrix_intro

You can set and get values at each location in the grid:

// snip: matrix_intro2

Matrices can be used in a variety of ways: for example, you can multiply them with a vector to modify the vector for things like movement, scaling, shearing, perspective projections, and more. You can also multiply two matrices together.

[TIP]
====
Computer graphics, and therefore game development, typically uses 4x4 matrices because they can be used to perform a wide range of common transformations.
====

Let's create a matrix that moves (translates) a vector by 5 units, on the X axis. First, we'll create a new matrix, using four Vector4s (four-dimensional vectors):

// snip: matrix_with_vector1

IMAGE of the matrix we just made goes here.

[NOTE]
====
When we multiply a three-dimensional vector by a 4x4 matrix, we add 1 to the end of the vector, forming a four-dimensional vector. The additional component  is commonly referred to as the w component.
====

Multiplying this matrix by a four-dimensional vector, `V`, performs the following result:

1*Vx  +  0*Vy  +  0*Vz  +  5*Vw = resultX
0*Vx  +  1*Vy  +  0*Vz  +  0*Vw = resultY
0*Vx  +  0*Vy  +  1*Vz  +  0*Vw = resultZ
0*Vx  +  0*Vy  +  0*Vz  +  1*Vw = resultW

For example, to multiply the point `(0,1,2)` (a Vector3) with this matrix:

. We first add our w component:
Vx = 0, Vy = 1, Vz = 2, Vw = 1

1*0  +  0*1  +  0*2  +  5*1 = 6
0*0  +  1*1  +  0*2  +  0*1 = 1
0*0  +  0*1  +  1*2  +  0*1 = 2
0*0  +  0*1  +  0*2  +  1*1 = 1

. Then we discard the fourth component, leaving our result. Our final result is therefore the Vector3 `(6,1,2)`.

Rather than doing all of this work ourselves, Unity provides a `MultiplyPoint` method as part of the `Matrix4x4` type:

// snip: matrix_with_vector2

[NOTE]
====
You might be wondering why the matrix has the fourth row at all, since it just means we need to add and remove a useless fourth component to our vectors. The reason it's there is to provide for operations like perspective projections. If you're only doing transformations like translations, rotations, and scales, you can get away with only using part of the matrix, and can use `Matrix4x4`s `MultplyPoint4x3` function instead. It's a bit faster, but can only be used for translations, rotations, and scales.
====

Unity also provides helper methods to translate points using a matrix:

// snip: matrix_translate

You can also rotate a point around the origin using matrices and quaternions:

// snip: matrix_rotate

In this case, the point has moved from in front of the origin to below it, resulting in the point `(0,-1,0)`.

If your vector represents a direction, and you want to use a matric to rotate the vector, you can use `MultiplyVector`. This method only uses the parts of the materics that are necessary to do a rotation, so it's a bit faster:

// snip: matrix_multiply_vector

You can also use a matrix scale a point away from the origin:

// snip: matrix_scale

Multiplying matrices together results in a new matrix that, when multiplied with a vector, produces the same result as if you'd multiplied the vector by each of the original matrices in order. In other words, if you think of matrices as an instruction to modify a point, you can combine multiple matrices into a single step. 

[TIP]
====
When you combine matrices together like this, we call it concatenating the matrices.
====

In the example below, we concatenate matrices:

// snip: matrix_concatenate

Like quaternions, the order of multiplication matters! Matrix multiplication is not commutative, while multiplying regular numbers is. 

For example: 2*5 == 5 * 2 == 10

But: translation * rotation != rotation * translation

This makes sense, because translating and then rotating a point will produce a different result than rotating it and then translating it.

Combining matrices with multiplication will apply them in reverse order of multiplication. Give a point P, and matrices A, B, and C:

P * (A * B * C) == (A * (B * (C * P)))

You can create a combined translate-rotate-scale matrix using the `Matrix4x4.TRS` method:

// snip: matrix_trs

This new matrix will scale, rotate, and then translate any point you apply it to.

You can also get a matrix that converts a point in the component's local space to world space, applying a translation, rotation, and scaling from this object as well as all of its parents:

// snip: matrix_transform

You can also get the matrix that converts from world-space to local space, too:

// snip: matrix_transform2

Phew. That's a lot of things you can do with matrices. In the following section we'll touch on what all this means for game development.

===== Discussion

// TODO discuss this


=== Working with Angles
// card: https://trello.com/c/sbK5cXEi

////
* Converting from degrees to radians and back
* Calculating the degrees between two vectors using dot product
////

==== Problem

You want to work with the angles between vectors.

==== Solution

In Unity, most rotations that are represented as Euler angles are done as degrees. As a refresher, there are 360 degrees in a circle. 

So we can rotate things using degrees:

TODO fix the snippets here

[TIP]
====
There are 2π radians in a circle.
====

Degrees are much more familiar to most people, but radians are often easier to calculate with. This is why parts of Unity, particularly related to maths, expect radians:

// sine of pi radians

You can convert from radians to degrees, and back again:

// snip: angles

==== Discussion

=== Finding the distance to a target
// card: https://trello.com/c/yE48E4MK

==== Problem

You want to check to see if an object is within a certain range of another.

==== Solution

You'll need to create and add a script to the object that needs to know when the other object is in range of it:

. Create a new C# script called RangeChecker, and add the following code to it:

// snip: range_checker

Attach this script to any object, and attach any other object to the script's Target field, and the script will detect when the target enters and exits the specified range.

==== Discussion



=== Finding the angle to a target
// card: https://trello.com/c/K1EQLOzW

==== Problem

You want to find the angle between two objects.

==== Solution

You'll need to create and add a script to the object that needs to know the angle between it and another object:

. Create a new C# script called RangeChecker, and add the following code to it:

// snip: angle_checker

Attach this script to any object, and attach any other object to the script's Target field, and the script will log the angle, in degrees, between the object's forward direction and the target object.


==== Discussion

The concept of 'angle between two objects' depends on you choosing at least one direction. You can't get the angle between two points in space, because there's an infinite number of possible angles between them. Instead, you need to pick a direction relative to the first object, and compare that to the direction to the second.
