[[chapter_maths]]
== Maths

=== Introduction

Maths is an unavoidable part of video game development. Like it or loath it, you need to use it, acknowledge it, and even downright embrace it to get anything done. This chapter explores some of the most common maths-related problems you'll encounter when developing games using Unity. 

[NOTE]
====
This isn't all the maths you'll need for game development: far from it! But it's enough maths to help out, and we've done our best to structure it around the problems you might want to solve using the maths, rather than the maths itself.
====

Ever wondered what a vector is? Or how to use a matrix? What about a quaternion?  We'll cover them here, while also touching on common maths problems in game development, like calculating the angles and distances to something else in your Unity-based game.

Read on for just enough Math development.

[TIP]
====
We can't recommend Paco Nathan's _Just Enough Math_ video series, also from O'Reilly Media, more highly. Check it out if you want to learn even more maths: http://shop.oreilly.com/product/110000527.do
====

=== Storing coordinates of varying dimensions using Vectors
// card: https://trello.com/c/K8vCgHZD

==== Problem

Game development involves a lot of coordinates, of varying dimensions:

* one-dimensional coordinates, such as `1` or `-9`
* two-dimensional coordinates, such as `8,3` or `-1,4`
* three-dimensional coordinates, such as `3,1,-3` or `-7,6,1`

Realistically, when you're building a game, as long as you're keeping track of what you need to keep track of, it often doesn't matter how you do it. However, one common, useful way of keeping track of coordinates is vectors.

Vectors a set of coordinates, of varying dimensions. Thus, our problem here is: how do I use vectors and Unity, and what can I use them for?

[TIP]
====
We often assign a specific meaning to vectors: in video games it's usually coordinates in geometry, but there's absolutely no reason you can't store anything you want in them. They're just a data structure.
====

==== Solution

To to provide a solution here we're going to have to unpack the problem a little. We admit, we wrote a deliberately broad problem statement, but that's so we can show you everything you need to know about vectors without having to have one tiny recipe for each manipulation or action you might want to make with a vector.

First up, in Unity, you can define a Vector2: one with two components, typically an x and a y. A Vector2 is typically used to represent a point in 2D space in a Unity game.

You can define a Vector2 with two dimensions: 

// snip: vector2
[source,swift]
----
Vector2 direction = new Vector2(0.0f, 2.0f);
----

Or use one of Unity's built-in vectors:
// snip: vector2builtin
[source,swift]
----
var up    = Vector2.up;    // ( 0,  1)
var down  = Vector2.down;  // ( 0, -1)
var left  = Vector2.left;  // (-1,  0)
var right = Vector2.right; // ( 1,  0)
var one   = Vector2.one;   // ( 1,  1)
var zero  = Vector2.zero;  // ( 0,  0)
----

[TIP]
====
You can learn more about Vector2 and 3in Unity's API documentation at  https://docs.unity3d.com/ScriptReference/Vector2.html and https://docs.unity3d.com/ScriptReference/Vector3.html
====

Unity also has a Vector3, a vector with three dimensions, which can be defined as follows:

// snip: vector3
[source,swift]
----
Vector3 point = new Vector3(1.0f, 2f, 3.5f);

var up      = Vector3.up;      // ( 0,  1,  0)
var down    = Vector3.down;    // ( 0, -1,  0)
var left    = Vector3.left;    // (-1,  0,  0)
var right   = Vector3.right;   // ( 1,  0,  0)
var forward = Vector3.forward; // ( 0,  0,  1)
var back    = Vector3.back;    // ( 0,  0, -1)
var one     = Vector3.one;     // ( 1,  1,  1)
var zero    = Vector3.zero;    // ( 0,  0,  0)
----

Every Transform component in Unity has local direction vectors defined, which are relative to their current rotation, for example forward could be accessed as:

// snip: local_directions
[source,swift]
----
var myForward = transform.forward;
----

Naturally, you can perform basic arithmetic with vectors. Vectors can be added together:

// snip: vector_add_subtract
[source,swift]
----
var v1 = new Vector3(1f, 2f, 3f);
var v2 = new Vector3(0f, 1f, 6f);

var v3 = v1 + v2; // (1, 3, 9)
----

And vectors can be subtracted from each other:
// snip: vector_subtract
[source,swift]
----
var v4 = v2 - v1; // (-1, -1, 3)
----

[NOTE]
====
The magnitude of a vector is its length. It's calculated by taking the square root of the sum of the squares of its components. A vector whose magnitude is 1 is called a "unit" vector.
====

You can also get the magnitude of a vector:

// snip: vector_magnitude
[source,swift]
----
var forwardMagnitude = Vector3.forward.magnitude; // = 1

var vectorMagnitude = new Vector3(2f, 5f, 3f).magnitude; // ~= 6.16
----

The magnitude can then be used to make other calculations, such as the distance between two vectors:

// snip: vector_distance
[source,swift]
----
var point1 = new Vector3(5f, 1f, 0f);
var point2 = new Vector3(7f, 0f, 2f);

var distance = (point2 - point1).magnitude; // = 3
----

There's also a built in method, `Distance`:

// snip: vector_distance2
[source,swift]
----
Vector3.Distance(point1, point2);
----

Calculating the magnitude of a vector requires a square root. However, if you just care about finding out if one distance is bigger than another, you can skip the square root. and work with the square of the magnitude. 

Doing this is a bit faster, and we care quite a lot about fast calculations in game development. To get this, use the `sqrMagnitude` property:

// snip: vector_magnitude2
[source,swift]
----
var distanceSquared = (point2 - point1).sqrMagnitude; // = 9
----

Lots of operations work best on vectors that have a magnitude of 1. A vector with magnitude of 1 is also called a "unit" vector, because its magnitude is a single unit (that is, one.) You can take a vector and produce a new one that has the same direction but with magnitude of 1 by dividing it by its own magnitude This is called "normalizing" it:

// snip: vector_normalise
[source,swift]
----
var bigVector = new Vector3(4, 7, 9); // magnitude = 12.08
var unitVector = bigVector / bigVector.magnitude; // magnitude = 1
----

This is a common operation, so you can directly access a normalized version of a vector by using the 'normalized' property:

// snip: vector_normalise2
[source,swift]
----
var unitVector2 = bigVector.normalized;
----

Vectors can also be scaled, either by a single regular number (a scalar), like so:

// snip: vector_scaling
[source,swift]
----
var v1 = Vector3.one * 4; // = (4, 4, 4)
----

Or by using the scale method and passing in another vector:

// snip: vector_scaling2
[source,swift]
----
v1.Scale(new Vector3(3f, 1f, 0f)); // = (12f, 4f, 0f)
----

You can also get the dot product of two vectors, which tells you the difference between the directions they are pointing. The dot product between two vectors aiming in the same direction is 1:

// snip: dot_product
[source,swift]
----
var parallel = Vector3.Dot(Vector3.left, Vector3.left); // 1
----

The dot product between two vectors aiming in the opposite directions is -1:

// snip: dot_product2
[source,swift]
----
var opposite = Vector3.Dot(Vector3.left, Vector3.right); // -1
----

The dot product between two vectors at right-angles to each other is 0:

// snip: dot_product3
[source,swift]
----
var orthogonal = Vector3.Dot(Vector3.up, Vector3.forward); // 0
----

The dot product is also the arc cosine of the angle between the two vectors (`Mathf.Acos works in radians):

// snip: dot_product4
[source,swift]
----
var orthoAngle = Mathf.Acos(orthogonal);
var orthoAngleDegrees = orthoAngle * Mathf.Rad2Deg; // = 90
----

The dot product is a great way to tell if an object is in front of, or behind, another:

// snip: dot_product5
[source,swift]
----
var directionToOtherObject = someOtherObjectPosition - transform.position;
var differenceFromMyForwardDirection = 
    Vector3.Dot(transform.forward, directionToOtherObject);

if (differenceFromMyForwardDirection > 0) {
    // The object is in front of us
} else if (differenceFromMyForwardDirection < 0) {
    // The object is behind us
} else {
    // The object neither before or behind us - it's at a perfect
    // right angle to our forward direction.
}
----

The cross product, a third vector orthogonal to (at right angles to) two input vectors, is also available:

// snip: cross_product
[source,swift]
----
var up = Vector3.Cross(Vector3.forward, Vector3.right);
----

[TIP]
====
The cross product is only defined for three-dimensional vectors. 
====

You can also get a new vector from two vectors, moving from one to the other at a certain magnitude. This is particularly useful to prevent overshooting. Here we move from `(0,0,0)` to `(1,1,1)`, without moving any futther than 0.5 units:

// snip: move_towards
[source,swift]
----
var moved = Vector3.MoveTowards(Vector3.zero, Vector3.one, 0.5f);
// = (0.3, 0.3, 0.3) (a vector that has a magnitude of 0.5)
----

Or reflect off a plane, defined by a normal:

// snip: vector_reflect
[source,swift]
----
var v = Vector3.Reflect(new Vector3(0.5f, -1f, 0f), Vector3.up);
// = (0.5, 1, 0)
----

Or lerp (linearly interpolate) between two input vectors, given a number between 0 and 1. If you provide 0, you'll get the first vector, if you provide 1 you'll get the second, and if you provide 0.5, you'll get somewhere right in the middle of the two:

// snip: vector_lerp
[source,swift]
----
var lerped = Vector3.Lerp(Vector3.zero, Vector3.one, 0.65f);
// = (0.65, 0.65, 0.65)
----

If you specify a number outside of the range of 0 to 1, lerp will clamp it to 0 to 1. You can prevent this by using `LerpUnclamped`:

// snip: vector_lerp2
[source,swift]
----
var unclamped = Vector3.LerpUnclamped(Vector3.zero, Vector3.right, 2.0f);
// = (2, 0, 0)
----

...that's just some of the things that you can do with vectors in Unity! But what are these useful for? Read on, for the discussion, to find out.

===== Discussion

////
* Vector2
* Vector3
* Common vectors (up, down, left, right, back, forward)
* Vector magnitude and what it is
* Vector addition and subtraction
* Measuring the distance between two points
* Quickly comparing the distance between two points using sqrMagnitude
* Scaling vectors
* Dot product and what it's useful for (measures the difference between the direction that two vectors point in)
* Cross product and what it's useful for (produces a vector that's orthogonal to both the inputs)
* Vector projection and what it's useful for
* MoveTowards is useful for making a vector move over time without overshooting
* Reflect is useful for bouncing a vector off a plane defined by a normal
* Lerp lets you interpolate between two vectors
* LerpUnclamped does the same, but doesn't clamp
////

That's just a taste of the basics of using vectors in Unity. But, as we said earlier, you never actually have to use vectors: if you have another way of keeping track of coordinates of a certain dimension, and it's working for you, then feel free to use that. You'll probably find Unity's inbuilt support for vectors, and the convenience functions and types provided, quite convenient though!

The mathematical operations that you can perform on a vector, provided by Unity, make a lot of things straightforward. The dot product, for example, can be used to tell if a point is in front of a player character, or behind them, or create a radar, to figure out where enemies are.

Vectors also make complex operations, like scaling, or rotating something, very straightforward. Instead of having to calculate each object and their relation to each other manually, you can just use vector math. 

Basically, vectors let you address geometry-related issues with significantly cleaner code than you would otherwise need. They're wonderful mathematical tools in your game development toolkit!

=== Rotating in 3D space
// card: https://trello.com/c/pQXNT5Rv

==== Problem

You want to rotate things in 3D space. 

==== Solution

To rotate in 3D space, you'll need to work with quaternions. Quaternions can be a tricky beast, inspiring fear in the eyes of game developers new and experienced alike. 

But really, all they are is a rotation, and for most game development purposes it doesn't matter if you don't quite understand exactly what a quaternion is and how it works: it's just a rotation.

For example, you can use a quaternion to define a rotation that rotates around 90 degrees on the X axis:

// snip: quaternions1
[source,swift]
----
var rotation = Quaternion.Euler(90, 0, 0);
----

And then use this to rotate a point around the origin:

// snip: quaternions2
[source,swift]
----
var input = new Vector3(0, 0, 1);

var result = rotation * input;
// = (0, -1, 0)
----

There is an identity quaternion, which represents no rotation at all:

// snip: quaternions3_identity
[source,swift]
----
var identity = Quaternion.identity;
----

And you can interpolate between two rotations using the `Slerp` method, which smoothly moves between rotations in a way that means the change in angle is constant at every step. This is better than a linear interpolation of angles, in which the angles change at a non-constant rate:

// snip: quaternions4
[source,swift]
----
var rotationX = Quaternion.Euler(90, 0, 0);

var halfwayRotated = Quaternion.Slerp(identity, rotationX, 0.5f);
----

[TIP]
====
Slerp is short for spherical linear interpolation.
====

You can also combine quaternions together: for example to rotate something around the Y axis, and then around the X axis, you multiply them (they're applied in the reverse order):

// snip: quaternions5
[source,swift]
----
var combinedRotation = Quaternion.Euler(90, 0, 0) * // rotate around X
                       Quaternion.Euler(0, 90, 0); // rotate around Y
----

[NOTE]
====
This combination is not commutative: the order of multiplication matters!
====

===== Discussion

You can do all sorts of exciting things with quaternions—rotations—including rotating a point around the origin and slerping (spherical linear interpolation) cleanly between different rotations: but what does it all mean for game development?

// TODO: what are Quaternions for?

=== Performing transformations in 3D space with Matrices
// card: https://trello.com/c/eWBNupad

==== Problem

You want to perform transformations in 3D space. 

==== Solution

Performing transformations on points and directions in 3D space means working with matrices. A matrix is just a grid of numbers:

// snip: matrix_intro
[source,swift]
----
var matrix = new Matrix4x4();
----

You can set and get values at each location in the grid:

// snip: matrix_intro2
[source,swift]
----
var m00 = matrix[0, 0];

matrix[0, 1] = 2f;
----

Matrices can be used in a variety of ways: for example, you can multiply them with a vector to modify the vector for things like movement, scaling, shearing, perspective projections, and more. You can also multiply two matrices together.

[TIP]
====
Computer graphics, and therefore game development, typically uses 4x4 matrices because they can be used to perform a wide range of common transformations.
====

Let's create a matrix that moves (translates) a vector by 5 units, on the X axis. First, we'll create a new matrix, using four Vector4s (four-dimensional vectors):

// snip: matrix_with_vector1
[source,swift]
----
var translationMatrix = new Matrix4x4(
    new Vector4(1, 0, 0, 0),
    new Vector4(0, 1, 0, 0),
    new Vector4(0, 0, 1, 0),
    new Vector4(5, 0, 0, 1)
);
----

IMAGE of the matrix we just made goes here.

[NOTE]
====
When we multiply a three-dimensional vector by a 4x4 matrix, we add 1 to the end of the vector, forming a four-dimensional vector. The additional component  is commonly referred to as the w component.
====

Multiplying this matrix by a four-dimensional vector, `V`, performs the following result:

1*Vx  +  0*Vy  +  0*Vz  +  5*Vw = resultX
0*Vx  +  1*Vy  +  0*Vz  +  0*Vw = resultY
0*Vx  +  0*Vy  +  1*Vz  +  0*Vw = resultZ
0*Vx  +  0*Vy  +  0*Vz  +  1*Vw = resultW

For example, to multiply the point `(0,1,2)` (a Vector3) with this matrix:

. We first add our w component:
Vx = 0, Vy = 1, Vz = 2, Vw = 1

1*0  +  0*1  +  0*2  +  5*1 = 6
0*0  +  1*1  +  0*2  +  0*1 = 1
0*0  +  0*1  +  1*2  +  0*1 = 2
0*0  +  0*1  +  0*2  +  1*1 = 1

. Then we discard the fourth component, leaving our result. Our final result is therefore the Vector3 `(6,1,2)`.

Rather than doing all of this work ourselves, Unity provides a `MultiplyPoint` method as part of the `Matrix4x4` type:

// snip: matrix_with_vector2
[source,swift]
----
var input = new Vector3(0, 1, 2);

var result = translationMatrix.MultiplyPoint(input);
// = (6, 1, 2)
----

[NOTE]
====
You might be wondering why the matrix has the fourth row at all, since it just means we need to add and remove a useless fourth component to our vectors. The reason it's there is to provide for operations like perspective projections. If you're only doing transformations like translations, rotations, and scales, you can get away with only using part of the matrix, and can use `Matrix4x4`s `MultplyPoint4x3` function instead. It's a bit faster, but can only be used for translations, rotations, and scales.
====

Unity also provides helper methods to translate points using a matrix:

// snip: matrix_translate
[source,swift]
----
var input = new Vector3(0, 1, 2);

var translationMatrix = Matrix4x4.Translate(new Vector3(5, 1, -2));
var result = translationMatrix.MultiplyPoint(input);
// = (5, 2, 0)
----

You can also rotate a point around the origin using matrices and quaternions:

// snip: matrix_rotate
[source,swift]
----
var rotate90DegreesAroundX = Quaternion.Euler(90, 0, 0);

var rotationMatrix = Matrix4x4.Rotate(rotate90DegreesAroundX);

var input = new Vector3(0, 0, 1);

var result = rotationMatrix.MultiplyPoint(input);
----

In this case, the point has moved from in front of the origin to below it, resulting in the point `(0,-1,0)`.

If your vector represents a direction, and you want to use a matric to rotate the vector, you can use `MultiplyVector`. This method only uses the parts of the materics that are necessary to do a rotation, so it's a bit faster:

// snip: matrix_multiply_vector
[source,swift]
----
result = rotationMatrix.MultiplyVector(input);
// = (0, -1, 0) - the same result.
----

You can also use a matrix scale a point away from the origin:

// snip: matrix_scale
[source,swift]
----
var scale2x2x2 = Matrix4x4.Scale(new Vector3(2f, 2f, 2f));

var input = new Vector3(1f, 2f, 3f);

var result = scale2x2x2.MultiplyPoint3x4(input);
// = (2, 4, 6)
----

Multiplying matrices together results in a new matrix that, when multiplied with a vector, produces the same result as if you'd multiplied the vector by each of the original matrices in order. In other words, if you think of a matrix as an instruction to modify a point, you can combine multiple matrices into a single step. 

[TIP]
====
When you combine matrices together like this, we call it concatenating the matrices.
====

In the example below, we concatenate matrices:

// snip: matrix_concatenate
[source,swift]
----
var translation = Matrix4x4.Translate(new Vector3(5, 0, 0));
var rotation = Matrix4x4.Rotate(Quaternion.Euler(90, 0, 0));
var scale = Matrix4x4.Scale(new Vector3(1, 5, 1));

var combined = translation * rotation * scale;

var input = new Vector3(1, 1, 1);
var result = combined.MultiplyPoint(input);
Debug.Log(result);
// = (6, 1, 5)
----

Like quaternions, the order of multiplication matters! Matrix multiplication is not commutative, while multiplying regular numbers is. 

For example: 2 * 5 == 5 * 2 == 10

But: translation * rotation != rotation * translation

This makes sense, because translating and then rotating a point will produce a different result than rotating it and then translating it.

Combining matrices with multiplication will apply them in reverse order of multiplication. Give a point P, and matrices A, B, and C:

P * (A * B * C) == (A * (B * (C * P)))

You can create a combined translate-rotate-scale matrix using the `Matrix4x4.TRS` method:

// snip: matrix_trs
[source,swift]
----
var transformMatrix = Matrix4x4.TRS(
    new Vector3(5, 0, 0),
    Quaternion.Euler(90, 0, 0),
    new Vector3(1, 5, 1)
);
----

This new matrix will scale, rotate, and then translate any point you apply it to.

You can also get a matrix that converts a point in the component's local space to world space, applying a translation, rotation, and scaling from this object as well as all of its parents:

// snip: matrix_transform
[source,swift]
----
var localToWorld = this.transform.localToWorldMatrix;
----

You can also get the matrix that converts from world-space to local space, too:

// snip: matrix_transform2
[source,swift]
----
var worldToLocal = this.transform.worldToLocalMatrix;
----

Phew. That's a lot of things you can do with matrices. In the following section we'll touch on what all this means for game development.

===== Discussion

// TODO discuss this

=== Working with Angles
// card: https://trello.com/c/sbK5cXEi

////
* Converting from degrees to radians and back
* Calculating the degrees between two vectors using dot product
////

==== Problem

You want to work with the angles between vectors.

==== Solution

In Unity, most rotations that are represented as Euler angles are done as degrees. 

// snip: angles1
[source,swift]
----
transform.Rotate(90, 0, 0); // rotate 90 degrees - one quarter circle - 
                            // around the X axis
----

So we can rotate things using degrees:

[TIP]
====
There are 360 _degrees_ in a circle; there are 2π _radians_ in a circle. They're just different units of measurements for angles.
====

Degrees are much more familiar to most people, but radians are often easier to calculate with. This is why parts of Unity, particularly related to maths, expect radians.  There are 2π radians in a circle.

// snip: angles2
[source,swift]
----
// The sine of pi radians (one half-circle) is zero
Mathf.Sin(Mathf.PI);  // = 0
----

You can convert from radians to degrees, and back again:

// snip: angles3
[source,swift]
----
// Converting 90 degrees to radians
var radians = 90 * Mathf.Deg2Rad; // ~= 1.57 (π / 2)

// Converting 2π radians to degrees
var degrees = 2 * Mathf.PI * Mathf.Rad2Deg; // = 360
----

[TIP]
====
The dot product of two unit vectors is equal to the _cosine_ of the angle between them.

If you have the cosine of a degree, you can get the original degree by taking the _arc cosine_ of it.
====

This means that you can find the angle between two vectors like this:

// snip: angles4
[source,swift]
----
var angle = Mathf.Acos(Vector3.Dot(Vector3.up, Vector3.left));
----

The result of this is π radians; if you want to show it to the user, you should convert it to degrees first.

==== Discussion



=== Finding the distance to a target
// card: https://trello.com/c/yE48E4MK

==== Problem

You want to check to see if an object is within a certain range of another.

==== Solution

You'll need to create and add a script to the object that needs to know when the other object is in range of it:

. Create a new C# script called RangeChecker, and add the following code to it:

// snip: range_checker
[source,swift]
----
public class RangeChecker : MonoBehaviour {

    // The object we want to check the distance to
    [SerializeField] Transform target;

    // If the target is within this many units of us, it's in range
    [SerializeField] float range = 5;

    // Remembers if 
    private bool targetInRange = false;

	void Update () {

        // Calculate the distance between the objects
        var distance = (target.position - transform.position).magnitude;

        if (distance <= range && targetInRange == false) {
            // If the object is now in range, and wasn't before, log it
            Debug.LogFormat("Target {0} entered range!", target.name);

            // Remember that it's in range for next frame
            targetInRange = true;

        } else if (distance > range && targetInRange == true) {
            // If the object is not in range, but was before, log it
            Debug.LogFormat("Target {0} exited range!", target.name);

            // Remember that not it's in range for next frame
            targetInRange = false;
        }

	}
}
----

Attach this script to any object, and attach any other object to the script's Target field, and the script will detect when the target enters and exits the specified range.

==== Discussion



=== Finding the angle to a target
// card: https://trello.com/c/K1EQLOzW

==== Problem

You want to find the angle between two objects.

==== Solution

You'll need to create and add a script to the object that needs to know the angle between it and another object:

. Create a new C# script called RangeChecker, and add the following code to it:

// snip: angle_checker
[source,swift]
----
public class AngleChecker : MonoBehaviour {

    // The object we want to find the angle to
    [SerializeField] Transform target;


	void Update () {

        // Get the normalised direction to the target
        var directionToTarget = (target.position - transform.position).normalized;

        // Take the dot product between that direction and our forward direction
        var dotProduct = Vector3.Dot(transform.forward, directionToTarget);

        // Get the angle
        var angle = Mathf.Acos(dotProduct);

        // Log the angle, limiting it to 1 decimal place
        Debug.LogFormat(
            "The angle between my forward direction and {0} is {1:F1}°",
            target.name, angle * Mathf.Rad2Deg
        );

	}
}
----

Attach this script to any object, and attach any other object to the script's Target field, and the script will log the angle, in degrees, between the object's forward direction and the target object.


==== Discussion

The concept of 'angle between two objects' depends on you choosing at least one direction. You can't get the angle between two points in space, because there's an infinite number of possible angles between them. Instead, you need to pick a direction relative to the first object, and compare that to the direction to the second.
