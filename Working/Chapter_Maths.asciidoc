[[chapter_maths]]
== Maths

=== Introduction

Maths is an unavoidable part of video game development. Like it or loath it, you need to use it, acknowledge it, and even downright embrace it to get anything done. This chapter explores six of the most common maths-related problems you'll encounter when developing games using Unity. 

Ever wondered what a vector is? Or how to use a matrix? What about a quaternion?  We'll cover them here, while also touching on common maths problems in game development, like calculating the angles and distances to something else in your Unity-based game.

Read on for just enough Math development.

[TIP]
====
We can't recommend Paco Nathan's _Just Enough Math_ video series, also from O'Reilly Media, more highly. Check it out if you want to learn even more maths: http://shop.oreilly.com/product/110000527.do
====

=== Understanding Vectors
// card: https://trello.com/c/K8vCgHZD

===== Problem

You want to work with vectors, which are a fundamental type of value in 3D graphics that can represent locations in space and directions.

===== Solution

To to provide a solution here we're going to have to unpack the problem a little. We admit, we wrote a deliberately broad problem statement, but that's so we can show you everything you need to know about vectors without having to have one tiny recipe for each manipulation or action you might want to make with a vector.

First up, in Unity, you can define a Vector2: one with two components, typically an x and a y. A Vector2 is typically used to represent a point in 2D space in a Unity game.

You can define a Vector2 with two numbers, or use one of Unity's built-in vectors:

// snip: vector2
[source,csharp]
----
// You define a Vector2 with two numbers: x and y
Vector2 direction = new Vector2(0.0f, 2.0f);

// Some built-in vectors:
var up    = Vector2.up;    // ( 0,  1)
var down  = Vector2.down;  // ( 0, -1)
var left  = Vector2.left;  // (-1,  0)
var right = Vector2.right; // ( 1,  0)
var one   = Vector2.one;   // ( 1,  1)
var zero  = Vector2.zero;  // ( 0,  0)
----

[TIP]
====
You can learn more about Vector2 and 3in Unity's API documentation at  https://docs.unity3d.com/ScriptReference/Vector2.html and https://docs.unity3d.com/ScriptReference/Vector3.html
====

Unity also has a Vector3, a vector with three numbers, which can be defined as follows:

// snip: vector3
[source,csharp]
----
// Vector3 is similar, but adds a third dimension
Vector3 point = new Vector3(1.0f, 2f, 3.5f);

var up      = Vector3.up;      // ( 0,  1,  0)
var down    = Vector3.down;    // ( 0, -1,  0)
var left    = Vector3.left;    // (-1,  0,  0)
var right   = Vector3.right;   // ( 1,  0,  0)
var forward = Vector3.forward; // ( 0,  0,  1)
var back    = Vector3.back;    // ( 0,  0, -1)
var one     = Vector3.one;     // ( 1,  1,  1)
var zero    = Vector3.zero;    // ( 0,  0,  0)
----

Every Transform component in Unity has local direction vectors defined, which are relative to their current rotation, for example forward could be accessed as:

// snip: local_directions
[source,csharp]
----
// Every Transform component has these vectors defined, relative
// to their current rotation. For example:

var myForward = transform.forward;
----

Naturally, you can perform basic arithmetic with vectors, such as addition and subtraction:

// snip: vector_add_subtract
[source,csharp]
----
// Vectors can be added together

var v1 = new Vector3(1f, 2f, 3f);
var v2 = new Vector3(0f, 1f, 6f);

var v3 = v1 + v2; // (1, 3, 9)

// Vectors can be subtracted from each other
var v4 = v2 - v1; // (-1, -1, 3)
----

You can also get the magnitude of a vector, and use this to make other calculations, such as the distance between two vectors:

// snip: vector_magnitude
[source,csharp]
----
// The "magnitude" of a vector is its length. It's calculated
// by taking the square root of the sum of the squares of its
// components.

// A vector whose magnitude is 1 is called a "unit" vector

var forwardMagnitude = Vector3.forward.magnitude; // = 1

var vectorMagnitude = new Vector3(2f, 5f, 3f).magnitude; // ~= 6.16

// You can use this to figure out the distance between two vectors:

var point1 = new Vector3(5f, 1f, 0f);
var point2 = new Vector3(7f, 0f, 2f);

var distance = (point2 - point1).magnitude; // = 3

// There's also the built-in method, Distance:
Vector3.Distance(point1, point2);

// Calculating the magnitude of a vector requires a square root.
// However, if you just care about finding out if one distance is
// bigger than another, you can skip the square root. and work with
// the square of the magnitude. Doing this is a bit faster, and we
// care quite a lot about fast calculations in game development. 
// To get this, use the sqrMagnitude property.

var distanceSquared = (point2 - point1).sqrMagnitude; // = 9

// Lots of operations work best on vectors that have a magnitude of 1.
// A vector with magnitude of 1 is also called a "unit" vector, because
// its magnitude is a single unit (that is, one.)

// You can take a vector and produce a new one that has the same 
// direction but with magnitude of 1 by dividing it by its own 
// magnitude. 
// This is called "normalizing" it.

var bigVector = new Vector3(4, 7, 9); // magnitude = 12.08
var unitVector = bigVector / bigVector.magnitude; // magnitude = 1

// This is a common operation, so you can directly access a 
// normalized version of a vector by using the 'normalized' property:
var unitVector2 = bigVector.normalized;

----

Vectors can also be scaled, either by a single regular number (a scalar) or by using the scale method and passing in another vector:

// snip: vector_scaling
[source,csharp]
----
// You can scale a vector by a scalar (a regular number) like this:
var v1 = Vector3.one * 4; // = (4, 4, 4)

// You can scale a vector by another by using the Scale method. This
// performs component-wise scaling; that is,
// v1.Scale(v2) = (v1.x * v2.x, v1.y * v2.y, v1.z * v2.z)
// Note that Scale modifies the vector in-place - it doesn't return
// a new vector.

v1.Scale(new Vector3(3f, 1f, 0f)); // = (12f, 4f, 0f)
----

You can also get the dot product of two vectors, which tells you the difference between the directions they are pointing:

// snip: dot_product
[source,csharp]
----
// The dot product measures the difference between the directions
// that two vectors are pointing.

// The dot product between two vectors aiming in the same direction
// is 1:

var parallel = Vector3.Dot(Vector3.left, Vector3.left); // 1

// The dot product between two vectors aiming in opposite directions
// is -1:

var opposite = Vector3.Dot(Vector3.left, Vector3.right); // -1

// The dot product between two vectors at right-angles to each other
// is 0:

var orthogonal = Vector3.Dot(Vector3.up, Vector3.forward); // 0

// The dot product is also the arc cosine of the angle between the
// two vectors. (Mathf.Acos works in radians.)

var orthoAngle = Mathf.Acos(orthogonal);
var orthoAngleDegrees = orthoAngle * Mathf.Rad2Deg; // = 90

// The dot product is a good way to tell if an object is in front
// of you or behind you.

var directionToOtherObject = someOtherObjectPosition - transform.position;
var differenceFromMyForwardDirection = 
    Vector3.Dot(transform.forward, directionToOtherObject);

if (differenceFromMyForwardDirection > 0) {
    // The object is in front of us
} else if (differenceFromMyForwardDirection < 0) {
    // The object is behind us
} else {
    // The object neither before or behind us - it's at a perfect
    // right angle to our forward direction.
}
----

The cross product, a vector orthogonal to both input vectors, is also available:

// snip: cross_product
[source,csharp]
----
// The cross product between two vectors returns a third vector
// that's orthogonal to (that is, at right angles to) both of them.

// The cross product is only defined for 3D vectors.

var up = Vector3.Cross(Vector3.forward, Vector3.right);
----

You can also get a new vector from two vectors, moving from one to the other at a certain magnitude:

// snip: move_towards
[source,csharp]
----
// MoveTowards returns a new vector that moves from A to B, limiting
// its total distance to a given factor. This is useful for 
// preventing overshooting.

// Move from (0,0,0) to (1,1,1), but don't move any further than
// 0.5 units
var moved = Vector3.MoveTowards(Vector3.zero, Vector3.one, 0.5f);
// = (0.3, 0.3, 0.3) (a vector that has a magnitude of 0.5)
----

Or reflect off a plane, defined by a normal:

// snip: vector_reflect
[source,csharp]
----
// Reflect will bounce a vector off a plane defined by a normal
var v = Vector3.Reflect(new Vector3(0.5f, -1f, 0f), Vector3.up);
// = (0.5, 1, 0)
----

Or lerp (linearly interpolate) between two vectors:

// snip: vector_lerp
[source,csharp]
----
// Lerp will linearly interpolate between two inputs, given a number
// between 0 and 1. If you provide 0, you'll get the first vector,
// if you provide 1 you'll provide the second, and if you provide
// 0.5, you'll get somewhere right in the middle of the two.
var lerped = Vector3.Lerp(Vector3.zero, Vector3.one, 0.65f);
// = (0.65, 0.65, 0.65)

// If you specify a number outside of the range of 0-1, Lerp will
// clamp it to 0-1. If you don't want this, use LerpUnclamped:

var unclamped = Vector3.LerpUnclamped(Vector3.zero, Vector3.right, 2.0f);
// = (2, 0, 0)
----

...that's just some of the things that you can do with vectors in Unity! But what are these useful for? Read on, for the discussion, to find out.

===== Discussion

////
* Vector2
* Vector3
* Common vectors (up, down, left, right, back, forward)
* Vector magnitude and what it is
* Vector addition and subtraction
* Measuring the distance between two points
* Quickly comparing the distance between two points using sqrMagnitude
* Scaling vectors
* Dot product and what it's useful for (measures the difference between the direction that two vectors point in)
* Cross product and what it's useful for (produces a vector that's orthogonal to both the inputs)
* Vector projection and what it's useful for
* MoveTowards is useful for making a vector move over time without overshooting
* Reflect is useful for bouncing a vector off a plane defined by a normal
* Lerp lets you interpolate between two vectors
* LerpUnclamped does the same, but doesn't clamp
////

=== Understanding Quaternions
// card: https://trello.com/c/pQXNT5Rv

===== Problem

You want to work with quaternions, which allow you to represent rotations in 3D space.

===== Solution

Quaternions can be a tricky beast, inspiring fear in the eyes of game developers new and experienced alike. But really, all they are is a rotation, and for most game development purposes it doesn't matter if you don't quite understand exactly what a quaternion is and how it works: it's just a rotation.

You can do all sorts of things with quaternions—rotations—including rotating a point around the origin and slerping (spherical linear interpolation) cleanly between different rotations:

// snip: quaternions
[source,csharp]
----
// Quaternions allow you to represent a rotation. All of Unity's
// rotations are internally stored as quaternions.

// The internals of Quaternions are based on complex numbers. For
// our purposes, it doesn't matter too much how they work internally;
// instead, it's enough to think of them as objects that represent 
// 'rotations'.

// Let's start by defining a rotation that rotates around 90 degrees
// on the X axis. When we refer to creating a rotation by rotating
// around the X, Y and Z axes, these angles are referred to as 
// "Euler angles" (named after the mathmatician Leonhardt Euler,
// whose name is pronounced "oiler", and not "yew-ler".)

var rotation = Quaternion.Euler(90, 0, 0);

// You can use this to rotate a point around the origin.
var input = new Vector3(0, 0, 1);

var result = rotation * input;
// = (0, -1, 0)

// The 'identity' quaternion is one that represents no rotation at
// all.
var identity = Quaternion.identity;

// You can interpolate between two rotations using the Slerp method.
// Slerp is short for "spherical linear interpolation", and is a way
// to smoothly move between to rotations in a way that means that the
// change in angle is constant at every step. This is better than
// a linear interpolation of angles, in which the angles change at a 
// non-constant rate.

var rotationX = Quaternion.Euler(90, 0, 0);

var halfwayRotated = Quaternion.Slerp(identity, rotationX, 0.5f);

// Quaternions can be combined together. For example, to rotate
// something around the Y axis and then around the X axis, you
// multiply them (they're applied in reverse order):

var combinedRotation = Quaternion.Euler(90, 0, 0) * // rotate around X
                       Quaternion.Euler(0, 90, 0); // rotate around Y

// Note that this combination is not "commutative" - the order of
// multiplication matters.
----

===== Discussion


=== Understanding matrices
// card: https://trello.com/c/eWBNupad

===== Problem

You want to work with matrices, which, in the context of 3D graphics, let you perform geometric transformations on points and directions.

===== Solution

A matrix is just a grid of numbers, where you can set and get values at each location in the grid:

// snip: matrix_intro
[source,csharp]
----
// A matrix is a grid of numbers, just like a vector is a column of
// numbers.
var matrix = new Matrix4x4();

// You can set and get the values at the various locations in a matrix.
var m00 = matrix[0, 0];

matrix[0, 1] = 2f;
----

Matrices can be used in a variety of ways: for example, you can multiply them with a vector to modify the vector for things like movement, scaling, shearing, perspective projections, and more. You can also multiply two matrices together.

[TIP]
====
Computer graphics, and therefore game development, typically uses 4x4 matrices because they can be used to perform a wide range of common transformations.
====

// snip: matrix_with_vector
[source,csharp]
----
// Matrices are powerful for two reasons: first, when you multiply them
// with a vector, you get a modified vector, and those modifications
// can be things like movement, rotation, scaling, shearing, perspective
// projections, and more. Second, when you multiply a matrix by another
// matrix, you get a matrix that combines the effect of both of them.

// In computer graphics, we typically use 4x4 matrices, because they
// can be used to perform the widest range of common geometrical 
// transformations.

// For example, let's create a matrix that moves ("translates") a vector 
// by 5 units on the X axis. Don't worry too much about the details of 
// why each number is in each location at the moment.

// Create a new matrix using four Vector4s. Each one of these is a 
// _column_, not a row.
var translationMatrix = new Matrix4x4(
    new Vector4(1, 0, 0, 0),
    new Vector4(0, 1, 0, 0),
    new Vector4(0, 0, 1, 0),
    new Vector4(5, 0, 0, 1)
);

// This creates a matrix that looks like this:
// 1  0  0  5
// 0  1  0  0
// 0  0  1  0
// 0  0  0  1

// When we multiply a 3-component vector by a 4x4 matrix, we add a 
// 1 to the end of the vector (forming a 4-component vector.) (This
// additional component is usually referred to as the 'w' component.)

// Multiplying this matrix by a 4-component vector V performs the 
// following result:
// 1*Vx  +  0*Vy  +  0*Vz  +  5*Vw = resultX
// 0*Vx  +  1*Vy  +  0*Vz  +  0*Vw = resultY
// 0*Vx  +  0*Vy  +  1*Vz  +  0*Vw = resultZ
// 0*Vx  +  0*Vy  +  0*Vz  +  1*Vw = resultW

// For example, let's multiply the point (0,1,2) with this matrix.

// First, we add our 'w' component:

// Vx = 0, Vy = 1, Vz = 2, Vw = 1

// 1*0  +  0*1  +  0*2  +  5*1 = 6
// 0*0  +  1*1  +  0*2  +  0*1 = 1
// 0*0  +  0*1  +  1*2  +  0*1 = 2
// 0*0  +  0*1  +  0*2  +  1*1 = 1

// We then discard the 4th component, and we have our result.

// Our final result is therefore (6, 1, 2).

// Rather than doing all of this work ourselves, Unity's Matrix4x4 type
// has a MultiplyPoint method.

var input = new Vector3(0, 1, 2);

var result = translationMatrix.MultiplyPoint(input);
// = (6, 1, 2)

// You might be wondering why the matrix has the 4th row at all,
// since it just means we need to add and remove a useless fourth
// component to our vectors. The reason why it's there is that the
// fourth row is necessary for operations like perspective projections.

// However, if you're only doing transformations like translations, 
// rotations and scales, you can get away with only using part of the
// matrix, and can use Matrix4x4's MultiplyPoint4x3 instead. It's
// a bit faster, but can only be used for translations, rotations
// and scales.
----

Unity provides helper methods to translate points using a matrix:

// snip: matrix_translate
[source,csharp]
----
var input = new Vector3(0, 1, 2);

// You can also create a matrix that translates a point using
// helper methods:

var translationMatrix = Matrix4x4.Translate(new Vector3(5, 1, -2));
var result = translationMatrix.MultiplyPoint(input);
// = (5, 2, 0)
----

You can also rotate a point around the origin using matrices and quaternions:

// snip: matrix_rotate
[source,csharp]
----
// Matrices can also rotate a point around the origin. First,
// create a quaternion that describes the rotation:

var rotate90DegreesAroundX = Quaternion.Euler(90, 0, 0);

var rotationMatrix = Matrix4x4.Rotate(rotate90DegreesAroundX);

var input = new Vector3(0, 0, 1);

var result = rotationMatrix.MultiplyPoint(input);
// = (0, -1, 0); the point has moved from in front of the origin to
// below it

// If your vector represents a direction, and you want to use 
// a matrix to rotate the vector, you can use MultiplyVector. This
// method uses only the parts of the matrix that are necessary to
// do a rotation. It's a bit faster.
result = rotationMatrix.MultiplyVector(input);
// = (0, -1, 0) - the same result.
----

Or scale a point away from the origin:

// snip: matrix_scale
[source,csharp]
----
// Matrices can also scale a point away from the origin.

var scale2x2x2 = Matrix4x4.Scale(new Vector3(2f, 2f, 2f));

var input = new Vector3(1f, 2f, 3f);

var result = scale2x2x2.MultiplyPoint3x4(input);
// = (2, 4, 6)
----

Multiplying matrices together results in a new matrix that, when multiplied with a vector, produces the same result as if you'd multiplied the vector by each of the original matrices in order. In other words, if you think of matrices as an instruction to modify a point, you can combine multiple matrices into a single step. 

[TIP]
====
When you combine matrices together like this, we call it concatenating the matrices.
====

In the example below, we concatenate matrices:

// snip: matrix_concatenate
[source,csharp]
----
// When you multiply matrices together, you get a new matrix that,
// when multiplied with a vector, produces the same result as if
// you'd multiplied the vector by each of the original matrices in 
// order. In other words, if you think of matrices as an "instruction"
// to modify a point, you can combine multiple matrices into a single
// step. When you combine matrices together like this, we call it
// "concatenating" the matrices.

var translation = Matrix4x4.Translate(new Vector3(5, 0, 0));
var rotation = Matrix4x4.Rotate(Quaternion.Euler(90, 0, 0));
var scale = Matrix4x4.Scale(new Vector3(1, 5, 1));

var combined = translation * rotation * scale;

var input = new Vector3(1, 1, 1);
var result = combined.MultiplyPoint(input);
Debug.Log(result);
// = (6, 1, 5)

// Note that, like quaternions, the order of multiplication matters! 
// Matrix multiplication is not "commutative", while multiplying 
// regular numbers is.

// For example, 2 * 5 == 5 * 2 == 10.
// But, translation * rotation != rotation * translation.
// This makes sense, because translating and then rotating a point
// will produce a different result than rotation and then translating 
// it.

// Combining matrices with multiplication will apply them in reverse
// order of multiplication. Given a point P and matrices A, B and C:

// P * (A * B * C) == (A * (B * (C * P)))

// You can create a combined translate-rotate-scale matrix using
// the Matrix4x4.TRS method:
var transformMatrix = Matrix4x4.TRS(
    new Vector3(5, 0, 0),
    Quaternion.Euler(90, 0, 0),
    new Vector3(1, 5, 1)
);

// This new matrix will scale, rotate, and then translate any point you
// apply it to.
----

You can also get a matrix that converts a point in the component's local space to world space, applying a translation, rotation, and scaling from this object as well as all of its parents:

// snip: matrix_transform
[source,csharp]
----
// You can get the matrix that converts a point in this component's
// local space to world space, applying the translation, rotation,
// and scaling from this object (as well as all of its parents.)

var localToWorld = this.transform.localToWorldMatrix;

// You can also get the matrix that converts from world-space to
// local space, too.
var worldToLocal = this.transform.worldToLocalMatrix;
----

Phew. That's a lot of things you can do with matrices. In the following section we'll touch on what all this means for game development.

===== Discussion


=== Working with Angles
// card: https://trello.com/c/sbK5cXEi

////
* Converting from degrees to radians and back
* Calculating the degrees between two vectors using dot product
////

===== Problem

You want to work with the angles between vectors.

===== Solution

In Unity, most rotations that are represented as Euler angles are done as degrees. As a refresher, there are 360 degrees in a circle. 

So we can rotate things using degrees:

TODO fix the snippets here

[TIP]
====
There are 2π radians in a circle.
====

Degrees are much more familiar to most people, but radians are often easier to calculate with. This is why parts of Unity, particularly related to maths, expect radians:

// sine of pi radians

You can convert from radians to degrees, and back again:

// snip: angles
[source,csharp]
----
// In Unity, most rotations that are represented as Euler angles
// are done as degrees. As a refresher, there are 360 degrees in a
// circle.

transform.Rotate(90, 0, 0); // rotate 90 degrees - one quarter circle - 
                            // around the X axis

// However, several math functions work in radians. There are 2π 
// radians in a circle.

// The sine of pi radians (one half-circle) is zero
Mathf.Sin(Mathf.PI);  // = 0

// Degrees are a little more familiar to most people, but radians are
// easier for calculations to work in. For this reason, most of the
// Mathf functions in Unity that deal with angles work in radians.

// You can convert from radians to degrees, and back again:

// Converting 90 degrees to radians
var radians = 90 * Mathf.Deg2Rad; // ~= 1.57 (π / 2)

// Converting 2π radians to degrees
var degrees = 2 * Mathf.PI * Mathf.Rad2Deg; // = 360

// The dot product of two unit vectors is equal to the cosine of the
// angle between them.

// If you have the cosine of a degree, you can get the original 
// degree by taking the arc cosine of it.

// This means that you can find the angle between two vectors like this:

var angle = Mathf.Acos(Vector3.Dot(Vector3.up, Vector3.left));
// = π radians; convert it to degrees if you want to show that
// to the user


----

===== Discussion

=== Finding the distance to a target
// card: https://trello.com/c/yE48E4MK

===== Problem

You want to check to see if an object is within a certain range of another.


===== Solution

. Create a new C# script called RangeChecker, and add the following code to it:

// snip: range_checker
[source,csharp]
----
public class RangeChecker : MonoBehaviour {

    // The object we want to check the distance to
    [SerializeField] Transform target;

    // If the target is within this many units of us, it's in range
    [SerializeField] float range = 5;

    // Remembers if 
    private bool targetInRange = false;

	void Update () {

        // Calculate the distance between the objects
        var distance = (target.position - transform.position).magnitude;

        if (distance <= range && targetInRange == false) {
            // If the object is now in range, and wasn't before, log it
            Debug.LogFormat("Target {0} entered range!", target.name);

            // Remember that it's in range for next frame
            targetInRange = true;

        } else if (distance > range && targetInRange == true) {
            // If the object is not in range, but was before, log it
            Debug.LogFormat("Target {0} exited range!", target.name);

            // Remember that not it's in range for next frame
            targetInRange = false;
        }

	}
}
----

Attach this script to any object, and attach any other object to the script's Target field, and the script will detect when the target enters and exits the specified range.

===== Discussion



=== Finding the angle to a target
// card: https://trello.com/c/K1EQLOzW

===== Problem

You want to find the angle between two objects.

===== Solution

. Create a new C# script called RangeChecker, and add the following code to it:

// snip: angle_checker
[source,csharp]
----
public class AngleChecker : MonoBehaviour {

    // The object we want to find the angle to
    [SerializeField] Transform target;


	void Update () {

        // Get the normalised direction to the target
        var directionToTarget = (target.position - transform.position).normalized;

        // Take the dot product between that direction and our forward direction
        var dotProduct = Vector3.Dot(transform.forward, directionToTarget);

        // Get the angle
        var angle = Mathf.Acos(dotProduct);

        // Log the angle, limiting it to 1 decimal place
        Debug.LogFormat(
            "The angle between my forward direction and {0} is {1:F1}°",
            target.name, angle * Mathf.Rad2Deg
        );

	}
}
----

Attach this script to any object, and attach any other object to the script's Target field, and the script will log the angle, in degrees, between the object's forward direction and the target object.


===== Discussion

The concept of 'angle between two objects' depends on you choosing at least one direction. You can't get the angle between two points in space, because there's an infinite number of possible angles between them. Instead, you need to pick a direction relative to the first object, and compare that to the direction to the second.
